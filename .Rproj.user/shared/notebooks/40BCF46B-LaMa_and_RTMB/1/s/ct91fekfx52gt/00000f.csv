"0","pnll = function(par) {"
"0","  getAll(par, dat) # makes everything contained available without $"
"0","  Gamma = tpm_g(Z, cbind(beta0, betaspline), ad = TRUE); ADREPORT(Gamma)"
"0","  Delta = stationary_p(Gamma, ad = TRUE); ADREPORT(Delta)"
"0","  delta = Delta[tod[1],]"
"0","  # exponentiating because all parameters strictly positive"
"0","  mu = exp(logmu); REPORT(mu)"
"0","  sigma = exp(logsigma); REPORT(sigma)"
"0","  kappa = exp(logkappa); REPORT(kappa)"
"0","  # calculating all state-dependent densities"
"0","  allprobs = matrix(1, nrow = length(step), ncol = N)"
"0","  ind = which(!is.na(step) & !is.na(angle)) # only for non-NA obs."
"0","  for(j in 1:N){"
"0","    allprobs[ind,j] = dgamma2(step[ind],mu[j],sigma[j])*dvm(angle[ind],0,kappa[j])"
"0","  }"
"0","  -forward_g(delta, Gamma[,,tod], allprobs, ad = TRUE) +"
"0","    penalty(betaspline, S, lambda) # this does all the penalization work"
"0","}"
