% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tpm_p.R
\name{tpm_p}
\alias{tpm_p}
\title{Build all transition probability matrices of a periodically inhomogeneous HMM}
\usage{
tpm_p(tod = 1:24, L = 24, beta, degree = 1, Z = NULL)
}
\arguments{
\item{tod}{Equidistant (generalized) time of day sequence, denoting the time point in a cycle.
For time of day and e.g. half-hourly data, this could be 1, ..., L and L = 48, or 0.5, 1, 1.5, ..., 24 and L = 24.}

\item{L}{Length of one full cycle, on the scale of tod}

\item{beta}{Matrix of coefficients for the off-diagonal elements of the transition probability matrix.
Needs to be of dimension c(N*(N-1), 2*degree+1), where the first column contains the intercepts.}

\item{degree}{Degree of the trigonometric link function. For each additional degree, one sine and one cosine frequency are added.}

\item{Z}{Defaults to zero if trigonometric link should be calculated. 
From an efficiency perspective, this option should be used within the likelhood function, as the basis expansion should not be redundantly calculated. \cr \cr
Furthermore, Z can also be a pre-calculated design matrix (with p columns), when one wants to use e.g. cyclic P-splines.
In that case, the dimension of beta needs to be c(N*(N-1), p+1) and a penalty term should be added at the end of the negative log-likelihood.}
}
\value{
Array of transition probability matrices of dimension c(N,N,length(tod))
}
\description{
Build all transition probability matrices of a periodically inhomogeneous HMM
}
\examples{
# hourly data 
tod = seq(1, 24, by = 1)
L = 24
beta = matrix(c(-1, 2, -1, -2, 1, -1), nrow = 2, byrow = TRUE)
Gamma = tpm_p(tod, L, beta, degree = 1)

# half-hourly data
## integer tod sequence
tod = seq(1, 48, by = 1)
L = 48
beta = matrix(c(-1, 2, -1, -2, 1, -1), nrow = 2, byrow = TRUE)
Gamma1 = tpm_p(tod, L, beta, degree = 1)

## equivalent specification
tod = seq(0.5, 24, by = 0.5)
L = 24
beta = matrix(c(-1, 2, -1, -2, 1, -1), nrow = 2, byrow = TRUE)
Gamma2 = tpm_p(tod, L, beta, degree = 1)

Gamma1-Gamma2 # same result

# cubic P-splines
set.seed(123)
nk = 8 # number of basis functions
tod = seq(0.5, 24, by = 0.5)
L = 24
k = L * 0:nk / nk # equidistant knots
Z = mgcv::cSplineDes(tod, k) ## cyclic spline design matrix
beta = matrix(c(-1, runif(8, -2, 2), # 9 parameters per off-diagonal element
                 -2, runif(8, -2, 2)), nrow = 2, byrow = TRUE)
Gamma = tpm_p(tod, L, beta, Z = Z)
}
