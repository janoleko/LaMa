"0","mllk_np = function(theta.star, x, Z, lambda){"
"0","  beta = matrix(theta.star[1:(2+2*ncol(Z))], nrow = 2)"
"0","  Gamma = tpm_g(Z = Z[-1,], beta = beta) # calculating all tpms"
"0","  delta = c(1, exp(theta.star[2+2*ncol(Z)+1]))"
"0","  delta = delta / sum(delta)"
"0","  mu = theta.star[2+2*ncol(Z)+1+1:2]"
"0","  sigma = exp(theta.star[2+2*ncol(Z)+3+1:2])"
"0","  # calculate all state-dependent probabilities"
"0","  allprobs = matrix(1, length(x), 2)"
"0","  for(j in 1:2){ allprobs[,j] = dnorm(x, mu[j], sigma[j]) }"
"0","  # return negative for minimization"
"0","  l = forward_g(delta, Gamma, allprobs)"
"0","  # penalize curvature"
"0","  penalty = sum(diff(beta[1,-1], differences = 4)^2)+"
"0","    sum(diff(beta[2,-1], differences = 4)^2)"
"0","  return(-l + lambda*penalty)"
"0","}"
