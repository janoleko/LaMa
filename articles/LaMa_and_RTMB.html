<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>LaMa and RTMB • LaMa</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="LaMa and RTMB">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">LaMa</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">2.0.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/Continuous_time_HMMs.html">Continuous-time HMMs</a></li>
    <li><a class="dropdown-item" href="../articles/HSMMs.html">Hidden semi-Markov models</a></li>
    <li><a class="dropdown-item" href="../articles/Inhomogeneous_HMMs.html">Inhomogeneous HMMs</a></li>
    <li><a class="dropdown-item" href="../articles/Intro_to_LaMa.html">Introduction to LaMa</a></li>
    <li><a class="dropdown-item" href="../articles/LaMa_and_RTMB.html">LaMa and RTMB</a></li>
    <li><a class="dropdown-item" href="../articles/Longitudinal_data.html">Longitudinal data</a></li>
    <li><a class="dropdown-item" href="../articles/MMMPPs.html">Markov-modulated (marked) Poisson processes</a></li>
    <li><a class="dropdown-item" href="../articles/Periodic_HMM.html">Periodic HMMs</a></li>
    <li><a class="dropdown-item" href="../articles/State_space_models.html">State space models</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/janoleko/LaMa/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>LaMa and RTMB</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/janoleko/LaMa/blob/main/vignettes/LaMa_and_RTMB.Rmd" class="external-link"><code>vignettes/LaMa_and_RTMB.Rmd</code></a></small>
      <div class="d-none name"><code>LaMa_and_RTMB.Rmd</code></div>
    </div>

    
    
<p>The recently introduced <code>R</code> package <code>RTMB</code>
conveniently allows for automatic differentiation for non-standard
statistical models written in plain <code>R</code> code. This enables
the estimation of very complicated models, potentially with complex
random effect structures. The process feels like magic because you have
access to analytic gradients – <em>drastically</em> increasing accuracy
and speed – without doing any calculations!</p>
<p><code>LaMa</code> now also allows for automatic differentiation with
<code>RTMB</code> for most of its functions when you set
<code>ad = TRUE</code>. Hence, estimation of latent Markov models is now
faster and more convenient, while model specification is very smooth and
less prone to errors – which at the current state tend to happen when
one is not experienced with <code>RTMB</code>.</p>
<p>Here we demonstrate how to use <code>LaMa</code> and
<code>RTMB</code> to fit hidden Markov models and their extensions. We
always start by loading both packages.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://janoleko.github.io/software/">LaMa</a></span><span class="op">)</span> <span class="co"># development version</span></span>
<span><span class="co">#&gt; Loading required package: RTMB</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/kaskr/RTMB" class="external-link">RTMB</a></span><span class="op">)</span></span></code></pre></div>
<p>For the purpose of this vignette, we will analyze the
<code>elephant</code> data set contained in the <code>LaMa</code>
package:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">elephant</span>, <span class="fl">5</span><span class="op">)</span></span>
<span><span class="co">#&gt;   tod      step     angle state</span></span>
<span><span class="co">#&gt; 1   9 0.3252437        NA     1</span></span>
<span><span class="co">#&gt; 2  10 0.2458265  2.234562     1</span></span>
<span><span class="co">#&gt; 3  11 0.2173252 -2.262418     1</span></span>
<span><span class="co">#&gt; 4  12 0.5114665 -2.958732     1</span></span>
<span><span class="co">#&gt; 5  13 0.3828494  1.811840     1</span></span></code></pre></div>
<div class="section level3">
<h3 id="basic-workflow">Basic workflow<a class="anchor" aria-label="anchor" href="#basic-workflow"></a>
</h3>
<p>The workflow with <code>RTMB</code> is basically always the same. We
need to</p>
<ul>
<li>define the negative log-likelihood function,</li>
<li>create an automatically differentiable objective function from it
and</li>
<li>fit the model by numerical minimization of the latter.</li>
</ul>
<p><code>RTMB</code> also provides many functions that make this process
very convenient.</p>
</div>
<div class="section level3">
<h3 id="simple-hmm">Simple HMM<a class="anchor" aria-label="anchor" href="#simple-hmm"></a>
</h3>
<p>We start by fitting a super simple stationary HMM with
state-dependent gamma distributions for the step lengths and von Mises
distributions for the turning angles. As a first step, we define the
initial parameter list <code>par</code> and a <code>dat</code> list that
contains the data and potential hyperparamters – here
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>,
the number of hidden states. The names <code>par</code> and
<code>dat</code> are of course arbitrary.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">par</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span>
<span>  logmu <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.3</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span>,      <span class="co"># initial means for step length (log-transformed)</span></span>
<span>  logsigma <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">0.7</span><span class="op">)</span><span class="op">)</span>, <span class="co"># initial sds for step length (log-transformed)</span></span>
<span>  logkappa <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">0.7</span><span class="op">)</span><span class="op">)</span>, <span class="co"># initial concentration for turning angle (log-transformed)</span></span>
<span>  eta <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">)</span>             <span class="co"># initial t.p.m. parameters (on logit scale)</span></span>
<span>  <span class="op">)</span>            </span>
<span><span class="va">dat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span>
<span>  step <span class="op">=</span> <span class="va">elephant</span><span class="op">$</span><span class="va">step</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5000</span><span class="op">]</span>, <span class="co"># only using a subset of the data for faster computation</span></span>
<span>  angle <span class="op">=</span> <span class="va">elephant</span><span class="op">$</span><span class="va">angle</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5000</span><span class="op">]</span>, </span>
<span>  N <span class="op">=</span> <span class="fl">2</span></span>
<span>  <span class="op">)</span></span></code></pre></div>
<p>As <code>par</code> is a named list of initial parameter values,
accessing the parameters later on is much more convenient than indexing.
You can also use a parameter vector with <code>RTMB</code>, but using a
named list makes our life so much easier.</p>
<p>We can now define the negative log-likelihood function in a similar
fashion to basic numerical ML</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nll</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">par</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">getAll</a></span><span class="op">(</span><span class="va">par</span>, <span class="va">dat</span><span class="op">)</span> <span class="co"># makes everything contained available without $</span></span>
<span>  <span class="va">Gamma</span> <span class="op">=</span> <span class="fu"><a href="../reference/tpm.html">tpm</a></span><span class="op">(</span><span class="va">eta</span><span class="op">)</span> <span class="co"># computes transition probability matrix from unconstrained eta</span></span>
<span>  <span class="va">delta</span> <span class="op">=</span> <span class="fu"><a href="../reference/stationary.html">stationary</a></span><span class="op">(</span><span class="va">Gamma</span><span class="op">)</span> <span class="co"># computes stationary distribution</span></span>
<span>  <span class="co"># exponentiating because all parameters strictly positive</span></span>
<span>  <span class="va">mu</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">logmu</span><span class="op">)</span></span>
<span>  <span class="va">sigma</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">logsigma</span><span class="op">)</span></span>
<span>  <span class="va">kappa</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">logkappa</span><span class="op">)</span></span>
<span>  <span class="co"># reporting statements for later use</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">mu</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">ADREPORT</a></span><span class="op">(</span><span class="va">mu</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">sigma</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">ADREPORT</a></span><span class="op">(</span><span class="va">sigma</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">kappa</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">ADREPORT</a></span><span class="op">(</span><span class="va">kappa</span><span class="op">)</span></span>
<span>  <span class="co"># calculating all state-dependent densities</span></span>
<span>  <span class="va">allprobs</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fl">1</span>, nrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">step</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">N</span><span class="op">)</span></span>
<span>  <span class="va">ind</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/which.html" class="external-link">which</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">step</span><span class="op">)</span> <span class="op">&amp;</span> <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">angle</span><span class="op">)</span><span class="op">)</span> <span class="co"># only for non-NA obs.</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">N</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">allprobs</span><span class="op">[</span><span class="va">ind</span>,<span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="../reference/gamma2.html">dgamma2</a></span><span class="op">(</span><span class="va">step</span><span class="op">[</span><span class="va">ind</span><span class="op">]</span>,<span class="va">mu</span><span class="op">[</span><span class="va">j</span><span class="op">]</span>,<span class="va">sigma</span><span class="op">[</span><span class="va">j</span><span class="op">]</span><span class="op">)</span><span class="op">*</span><span class="fu"><a href="../reference/dvm.html">dvm</a></span><span class="op">(</span><span class="va">angle</span><span class="op">[</span><span class="va">ind</span><span class="op">]</span>,<span class="fl">0</span>,<span class="va">kappa</span><span class="op">[</span><span class="va">j</span><span class="op">]</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="op">-</span><span class="fu"><a href="../reference/forward.html">forward</a></span><span class="op">(</span><span class="va">delta</span>, <span class="va">Gamma</span>, <span class="va">allprobs</span><span class="op">)</span> <span class="co"># simple forward algorithm</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>but a few points should be made here:</p>
<ul>
<li>Most prominently, the negative log-likelihood is a function of the
parameters to be estimated <em>only</em> while data and other parameters
are not passed as an argument at this stage. This is something to get
used to (I know), but just the way <code>RTMB</code> works.</li>
<li>The <code><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">getAll()</a></code> function is very useful and you should use
it in the first line to unpack both the <code>par</code> and the
<code>dat</code> list, making all elements available without the
<code>$</code> operator. At this stage, <code>nll</code> just takes the
dat object from the global environment.</li>
<li>Parameter transformations are of course still necessary, i.e. all
parameters in <code>par</code> should be unconstrained.</li>
<li>You might wonder how on earth <code>RTMB</code> can calculate the
gradient of parameters in distributions like the gamma or von Mises
distribution. The answer is: It can’t but provides its own version of
all standard distributions like <code><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">dnorm()</a></code>,
<code><a href="https://rdrr.io/r/stats/Binomial.html" class="external-link">dbinom()</a></code>, etc. In this case both <code><a href="../reference/gamma2.html">dgamma2()</a></code> and
<code><a href="../reference/dvm.html">dvm()</a></code> come from <code>LaMa</code> as these are
non-standard, but under the hood build on <code>RTMB</code> functions
(<code><a href="../reference/gamma2.html">dgamma2()</a></code> is actually just a convenience function that
reparametrizes the gamma distribution in terms of mean and standard
deviation).</li>
<li>Actually, most of the standard functions (e.g. <code><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum()</a></code>),
operators (e.g. <code>%*%</code>) and methods (e.g. <code>matrix</code>)
are “overwritten” when called inside <code>MakeADFun()</code> but you
typically don’t notice that and should not care – but this is how the
magic works.</li>
<li>the <code><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT()</a></code> function offered by <code>RTMB</code> is
really convenient as any quantities calculated in the likelihood
function (for which you have written the code anyway), if reported, will
be available after optimization, while the report statements are ignored
during optimization. So no annoying backtransformations anymore,
wohoo!</li>
<li>for simple parameter transformations, <code><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">ADREPORT()</a></code> is
also great, because it calculates standard deviations for
<code><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">ADREPORT()</a></code>ed quantities, based on the delta method. Just
note that the delta method is not advisable for complex non-linear and
multivariate transformations.</li>
</ul>
<p>Having defined the negative log-likelihood, we can now create the
autmatically differentiable objective function and fit the model. This
needs a little explanation: At this point, <code>RTMB</code> takes the
negative log-likelihood function and generates its own version of it,
including a gradient. <code>MakeADFun()</code> now also grabs whatever
is saved as <code>dat</code> in the global environment and
<em>bakes</em> it into the objective function. Therefore, changes to
<code>dat</code> after this point will have no effect on the
optimization result. We set <code>silent = TRUE</code> to suppress
printing of the optimization process.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">obj</span> <span class="op">=</span> <span class="fu">MakeADFun</span><span class="op">(</span><span class="va">nll</span>, <span class="va">par</span>, silent <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="co"># creating the objective function</span></span></code></pre></div>
<p>Let’s check out <code>obj</code>:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">obj</span><span class="op">)</span></span>
<span><span class="co">#&gt;  [1] "par"      "fn"       "gr"       "he"       "hessian"  "method"  </span></span>
<span><span class="co">#&gt;  [7] "retape"   "env"      "report"   "simulate"</span></span></code></pre></div>
<p>It contains the initial parameter <code>par</code> (now tranformed to
a named vector), the objective function <code>fn</code> (which in this
case just evaluates <code>nll</code> but faster), its gradient
<code>gr</code> and Hessian <code>he</code>.</p>
<p>If we now call these functions without any argument, we get the
corresponding values at the initial parameter vector.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">obj</span><span class="op">$</span><span class="va">par</span></span>
<span><span class="co">#&gt;      logmu      logmu   logsigma   logsigma   logkappa   logkappa        eta </span></span>
<span><span class="co">#&gt; -1.2039728  0.0000000 -1.6094379 -0.3566749 -1.6094379 -0.3566749 -2.0000000 </span></span>
<span><span class="co">#&gt;        eta </span></span>
<span><span class="co">#&gt; -2.0000000</span></span>
<span><span class="va">obj</span><span class="op">$</span><span class="fu">fn</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 16584.4</span></span>
<span><span class="va">obj</span><span class="op">$</span><span class="fu">gr</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt;          [,1]     [,2]     [,3]      [,4]     [,5]      [,6]     [,7]      [,8]</span></span>
<span><span class="co">#&gt; [1,] 230.5857 -1218.71 56.12643 -5906.308 30.71142 -408.9433 63.43363 -95.75145</span></span></code></pre></div>
<p>We are now ready to optimize the objective function. The optimization
routine <code><a href="https://rdrr.io/r/stats/nlminb.html" class="external-link">nlminb()</a></code> is very robust and conveniently allows us
to provide a gradient function. Alternatively, you can also use
<code><a href="https://rdrr.io/r/stats/optim.html" class="external-link">optim()</a></code> or any other optimizer you like that allows you to
pass a gradient function.</p>
<p>Indeed, we do not provide the Hessian to <code><a href="https://rdrr.io/r/stats/nlminb.html" class="external-link">nlminb()</a></code>
because while evaluating the Hessian is very fast with
<code>RTMB</code>, optimization is still much faster if we use a
quasi-Newton algorithm that approximates the current Hessian based on
previous gradient evaluations, compared to using full
Newton-Raphson.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">opt</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlminb.html" class="external-link">nlminb</a></span><span class="op">(</span><span class="va">obj</span><span class="op">$</span><span class="va">par</span>, <span class="va">obj</span><span class="op">$</span><span class="va">fn</span>, <span class="va">obj</span><span class="op">$</span><span class="va">gr</span><span class="op">)</span> <span class="co"># optimization</span></span></code></pre></div>
<p>We can check out the estimated parameter and function value by</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">opt</span><span class="op">$</span><span class="va">par</span></span>
<span><span class="co">#&gt;      logmu      logmu   logsigma   logsigma   logkappa   logkappa        eta </span></span>
<span><span class="co">#&gt; -1.1816492  0.9109406 -1.5899770  0.3893447 -2.5112980  0.4258548 -1.6174757 </span></span>
<span><span class="co">#&gt;        eta </span></span>
<span><span class="co">#&gt; -1.5348844</span></span>
<span><span class="va">opt</span><span class="op">$</span><span class="va">objective</span></span>
<span><span class="co">#&gt; [1] 13617.45</span></span></code></pre></div>
<p>Note that the naming here is determined by <code><a href="https://rdrr.io/r/stats/nlminb.html" class="external-link">nlminb()</a></code>. If
you use a different optimizer, these may be called differently.</p>
<p>Much nicer however, is that <code>obj</code> (yes <code>obj</code>
not <code>opt</code>) is automatically updated after the optimization.
Note that calling <code>obj$gr()</code> after optimization now gives the
gradient at the optimum, while <code>obj$fn()</code> still gives the
objective at the starting value and <code>obj$par</code> is not updated
but still the initial parameter vector (kind of confusing).</p>
<p>To get our estimated parameters on their natural scale, we don’t have
to do the backtransformation manually. We can just run the
reporting:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mod</span> <span class="op">=</span> <span class="va">obj</span><span class="op">$</span><span class="fu">report</span><span class="op">(</span><span class="op">)</span> <span class="co"># runs the reporting from the negative log-likelihood once</span></span>
<span><span class="op">(</span><span class="va">delta</span> <span class="op">=</span> <span class="va">mod</span><span class="op">$</span><span class="va">delta</span><span class="op">)</span></span>
<span><span class="co">#&gt;   state 1   state 2 </span></span>
<span><span class="co">#&gt; 0.4828971 0.5171029</span></span>
<span><span class="op">(</span><span class="va">Gamma</span> <span class="op">=</span> <span class="va">mod</span><span class="op">$</span><span class="va">Gamma</span><span class="op">)</span></span>
<span><span class="co">#&gt;           [,1]      [,2]</span></span>
<span><span class="co">#&gt; [1,] 0.8227198 0.1772802</span></span>
<span><span class="co">#&gt; [2,] 0.1655533 0.8344467</span></span>
<span><span class="op">(</span><span class="va">mu</span> <span class="op">=</span> <span class="va">mod</span><span class="op">$</span><span class="va">mu</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.3067724 2.4866604</span></span>
<span><span class="op">(</span><span class="va">sigma</span> <span class="op">=</span> <span class="va">mod</span><span class="op">$</span><span class="va">sigma</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.2039303 1.4760132</span></span>
<span><span class="op">(</span><span class="va">kappa</span> <span class="op">=</span> <span class="va">mod</span><span class="op">$</span><span class="va">kappa</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.08116282 1.53089842</span></span></code></pre></div>
<p>which works because of the <code><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT()</a></code> statements in the
likelihood function. Note that <code>delta</code>, <code>Gamma</code>
and <code>allprobs</code> are always reported by default when using
<code><a href="../reference/forward.html">forward()</a></code> which is very useful for e.g. state decoding with
<code><a href="../reference/viterbi.html">viterbi()</a></code>, because many downstream <code>LaMa</code>
functions take these arguments as inputs. As the state-dependent
parameters depend on the specific model formulation, these need to be
reported manually by the user specifying the negative log-likelihood.
Having all the parameters, we can plot the decoded time series</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mod</span><span class="op">$</span><span class="va">states</span> <span class="op">=</span> <span class="fu"><a href="../reference/viterbi.html">viterbi</a></span><span class="op">(</span><span class="va">mod</span><span class="op">$</span><span class="va">delta</span>, <span class="va">mod</span><span class="op">$</span><span class="va">Gamma</span>, <span class="va">mod</span><span class="op">$</span><span class="va">allprobs</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># defining color vector</span></span>
<span><span class="va">color</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"orange"</span>, <span class="st">"deepskyblue"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">elephant</span><span class="op">$</span><span class="va">step</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">200</span><span class="op">]</span>, type <span class="op">=</span> <span class="st">"h"</span>, xlab <span class="op">=</span> <span class="st">"time"</span>, ylab <span class="op">=</span> <span class="st">"step length"</span>, </span>
<span>     col <span class="op">=</span> <span class="va">color</span><span class="op">[</span><span class="va">mod</span><span class="op">$</span><span class="va">states</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">200</span><span class="op">]</span><span class="op">]</span>, bty <span class="op">=</span> <span class="st">"n"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html" class="external-link">legend</a></span><span class="op">(</span><span class="st">"topright"</span>, col <span class="op">=</span> <span class="va">color</span>, lwd <span class="op">=</span> <span class="fl">1</span>, legend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"state 1"</span>, <span class="st">"state 2"</span><span class="op">)</span>, bty <span class="op">=</span> <span class="st">"n"</span><span class="op">)</span></span></code></pre></div>
<p><img src="LaMa_and_RTMB_files/figure-html/decoding-1.png" width="85%" style="display: block; margin: auto;"></p>
<p>or the estimated state-dependent distributions.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">oldpar</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">elephant</span><span class="op">$</span><span class="va">step</span>, prob <span class="op">=</span> <span class="cn">TRUE</span>, breaks <span class="op">=</span> <span class="fl">40</span>, </span>
<span>     bor <span class="op">=</span> <span class="st">"white"</span>, main <span class="op">=</span> <span class="st">""</span>, xlab <span class="op">=</span> <span class="st">"step length"</span><span class="op">)</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/graphics/curve.html" class="external-link">curve</a></span><span class="op">(</span><span class="va">delta</span><span class="op">[</span><span class="va">j</span><span class="op">]</span> <span class="op">*</span> <span class="fu"><a href="../reference/gamma2.html">dgamma2</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">mu</span><span class="op">[</span><span class="va">j</span><span class="op">]</span>, <span class="va">sigma</span><span class="op">[</span><span class="va">j</span><span class="op">]</span><span class="op">)</span>, </span>
<span>                    lwd <span class="op">=</span> <span class="fl">2</span>, add <span class="op">=</span> <span class="cn">T</span>, col <span class="op">=</span> <span class="va">color</span><span class="op">[</span><span class="va">j</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/curve.html" class="external-link">curve</a></span><span class="op">(</span><span class="va">delta</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">*</span><span class="fu"><a href="../reference/gamma2.html">dgamma2</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">mu</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>, <span class="va">sigma</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span> <span class="va">delta</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">*</span><span class="fu"><a href="../reference/gamma2.html">dgamma2</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">mu</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>, <span class="va">sigma</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span>, </span>
<span>      lwd <span class="op">=</span> <span class="fl">2</span>, lty <span class="op">=</span> <span class="fl">2</span>, add <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html" class="external-link">legend</a></span><span class="op">(</span><span class="st">"top"</span>, lwd <span class="op">=</span> <span class="fl">2</span>, col <span class="op">=</span> <span class="va">color</span>, legend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"state 1"</span>, <span class="st">"state 2"</span><span class="op">)</span>, bty <span class="op">=</span> <span class="st">"n"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">elephant</span><span class="op">$</span><span class="va">angle</span>, prob <span class="op">=</span> <span class="cn">TRUE</span>, breaks <span class="op">=</span> <span class="fl">40</span>, </span>
<span>     bor <span class="op">=</span> <span class="st">"white"</span>, main <span class="op">=</span> <span class="st">""</span>, xlab <span class="op">=</span> <span class="st">"turning angle"</span><span class="op">)</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/graphics/curve.html" class="external-link">curve</a></span><span class="op">(</span><span class="va">delta</span><span class="op">[</span><span class="va">j</span><span class="op">]</span> <span class="op">*</span> <span class="fu"><a href="../reference/dvm.html">dvm</a></span><span class="op">(</span><span class="va">x</span>, <span class="fl">0</span>, <span class="va">kappa</span><span class="op">[</span><span class="va">j</span><span class="op">]</span><span class="op">)</span>, </span>
<span>                    lwd <span class="op">=</span> <span class="fl">2</span>, add <span class="op">=</span> <span class="cn">T</span>, col <span class="op">=</span> <span class="va">color</span><span class="op">[</span><span class="va">j</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/curve.html" class="external-link">curve</a></span><span class="op">(</span><span class="va">delta</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">*</span><span class="fu"><a href="../reference/dvm.html">dvm</a></span><span class="op">(</span><span class="va">x</span>, <span class="fl">0</span>, <span class="va">kappa</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span> <span class="va">delta</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">*</span><span class="fu"><a href="../reference/dvm.html">dvm</a></span><span class="op">(</span><span class="va">x</span>, <span class="fl">0</span>, <span class="va">kappa</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span>, </span>
<span>      lwd <span class="op">=</span> <span class="fl">2</span>, lty <span class="op">=</span> <span class="fl">2</span>, add <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span></code></pre></div>
<p><img src="LaMa_and_RTMB_files/figure-html/statedepdist-1.png" width="85%" style="display: block; margin: auto;"></p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span><span class="va">oldpar</span><span class="op">)</span> <span class="co"># resetting to default</span></span></code></pre></div>
<p>Lastly, we can also use the <code>sdreport()</code> function to
directly give us standard errors for our unconstrained parameters and
everything we <code><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">ADREPORT()</a></code>ed. </p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sdr</span> <span class="op">=</span> <span class="fu">sdreport</span><span class="op">(</span><span class="va">obj</span><span class="op">)</span></span></code></pre></div>
<p>We can then get an overview of the estimated parameters and
<code><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">ADREPORT()</a></code>ed quantities as well as their standard errors
by</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">sdr</span><span class="op">)</span></span>
<span><span class="co">#&gt;             Estimate  Std. Error</span></span>
<span><span class="co">#&gt; logmu    -1.18164921 0.015816840</span></span>
<span><span class="co">#&gt; logmu     0.91094060 0.012568349</span></span>
<span><span class="co">#&gt; logsigma -1.58997698 0.023262636</span></span>
<span><span class="co">#&gt; logsigma  0.38934467 0.018793398</span></span>
<span><span class="co">#&gt; logkappa -2.51129801 0.366127132</span></span>
<span><span class="co">#&gt; logkappa  0.42585477 0.027176879</span></span>
<span><span class="co">#&gt; eta      -1.61747569 0.058270035</span></span>
<span><span class="co">#&gt; eta      -1.53488440 0.056943182</span></span>
<span><span class="co">#&gt; mu        0.30677239 0.004852170</span></span>
<span><span class="co">#&gt; mu        2.48666039 0.031253215</span></span>
<span><span class="co">#&gt; sigma     0.20393031 0.004743956</span></span>
<span><span class="co">#&gt; sigma     1.47601320 0.027739303</span></span>
<span><span class="co">#&gt; kappa     0.08116282 0.029715911</span></span>
<span><span class="co">#&gt; kappa     1.53089842 0.041605041</span></span></code></pre></div>
<p>To get the estimated parameters or their standard errors in list
format, type</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># estimated parameter in list format</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">as.list</a></span><span class="op">(</span><span class="va">sdr</span>, <span class="st">"Estimate"</span><span class="op">)</span></span>
<span><span class="co"># parameter standard errors in list format</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">as.list</a></span><span class="op">(</span><span class="va">sdr</span>, <span class="st">"Std"</span><span class="op">)</span></span></code></pre></div>
<p>and to get the estimates and standard errors for
<code><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">ADREPORT()</a></code>ed quantities in list format, type</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># adreported parameters as list</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">as.list</a></span><span class="op">(</span><span class="va">sdr</span>, <span class="st">"Estimate"</span>, report <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co"># their standard errors</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">as.list</a></span><span class="op">(</span><span class="va">sdr</span>, <span class="st">"Std"</span>, report <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="covariate-effects">Covariate effects<a class="anchor" aria-label="anchor" href="#covariate-effects"></a>
</h3>
<p>Generalizing to covariate effects is also straightforward. For
example, we can add time of day variation to the state process. In this
case we want to obtain a state process model of the form
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">logit</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>γ</mi><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mi>β</mi><mn>0</mn><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo>+</mo><msubsup><mi>β</mi><mn>1</mn><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo>sin</mo><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><mfrac><mrow><mn>2</mn><mi>π</mi><mi>t</mi></mrow><mn>24</mn></mfrac><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mo>+</mo><msubsup><mi>β</mi><mn>2</mn><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo>cos</mo><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><mfrac><mrow><mn>2</mn><mi>π</mi><mi>t</mi></mrow><mn>24</mn></mfrac><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mo>+</mo><msubsup><mi>β</mi><mn>3</mn><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo>sin</mo><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><mfrac><mrow><mn>2</mn><mi>π</mi><mi>t</mi></mrow><mn>12</mn></mfrac><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mo>+</mo><msubsup><mi>β</mi><mn>4</mn><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo>cos</mo><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><mfrac><mrow><mn>2</mn><mi>π</mi><mi>t</mi></mrow><mn>12</mn></mfrac><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">
\text{logit}(\gamma_{ij}^{(t)}) = \beta_0^{(ij)} + \beta_1^{(ij)} \sin \bigl(\frac{2 \pi t}{24}\bigr) + \beta_2^{(ij)} \cos \bigl(\frac{2 \pi t}{24}\bigr) + \beta_3^{(ij)} \sin \bigl(\frac{2 \pi t}{12}\bigr) + \beta_4^{(ij)} \cos \bigl(\frac{2 \pi t}{12}\bigr),
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
is the time of day. For this we compute the trigonometric basis design
matrix <code>Z</code> corresponding to above predictor and add the time
of day to the <code>dat</code> list. The <code>LaMa</code> function
<code><a href="../reference/trigBasisExp.html">trigBasisExp()</a></code> does this very conveniently.</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># building trigonometric basis desing matrix (in this case no intercept column)</span></span>
<span><span class="va">Z</span> <span class="op">=</span> <span class="fu"><a href="../reference/trigBasisExp.html">trigBasisExp</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">24</span>, degree <span class="op">=</span> <span class="fl">2</span><span class="op">)</span> <span class="co"># convenience function from LaMa</span></span>
<span><span class="co"># only compute the 24 unique values and index later for entire time series</span></span>
<span><span class="va">dat</span><span class="op">$</span><span class="va">Z</span> <span class="op">=</span> <span class="va">Z</span> <span class="co"># adding design matrix to dat</span></span>
<span><span class="va">dat</span><span class="op">$</span><span class="va">tod</span> <span class="op">=</span> <span class="va">elephant</span><span class="op">$</span><span class="va">tod</span> <span class="co"># adding time of day to dat for indexing</span></span></code></pre></div>
<p>We also need to change the parameter list <code>par</code> to include
the regression parameters for the time of day. The regression parameters
for the state process will typically have the form of a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>×</mo><mi>p</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N (N-1) \times p+1</annotation></semantics></math>
matrix, where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>
is the number of states and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
is the number of regressors – this format is also expected by
<code><a href="../reference/tpm_g.html">tpm_g()</a></code> which computes the array of transition matrices
based on the design and parameter matrix. Another lovely convenience
that <code>RTMB</code> allows for is that, in our parameter list, we can
have matrices, making reshaping of vectors to matrices inside the
likelihood function unnessesary.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">par</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>logmu <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.3</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span>, </span>
<span>           logsigma <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">0.7</span><span class="op">)</span><span class="op">)</span>,</span>
<span>           logkappa <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">0.7</span><span class="op">)</span><span class="op">)</span>,</span>
<span>           beta <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">)</span>, </span>
<span>                           <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">2</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">Z</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span> <span class="co"># 2 times 4+1 matrix</span></span>
<span><span class="co"># replacing eta with regression parameter matrix, initializing slopes at zero</span></span></code></pre></div>
<p>We can now define a more general likelihood function with the main
difference being the use of <code><a href="../reference/tpm_g.html">tpm_g()</a></code> instead of
<code><a href="../reference/tpm.html">tpm()</a></code> and the inclusion of the time of day in the
transition matrix calculation. This leads to us using
<code><a href="../reference/stationary_p.html">stationary_p()</a></code> instead of <code><a href="../reference/stationary.html">stationary()</a></code> to
calculate the initial distribuion and <code><a href="../reference/forward_g.html">forward_g()</a></code> instead
of <code><a href="../reference/forward.html">forward()</a></code> to calculate the log-likelihood.</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nll2</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">par</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">getAll</a></span><span class="op">(</span><span class="va">par</span>, <span class="va">dat</span><span class="op">)</span> <span class="co"># makes everything contained available without $</span></span>
<span>  <span class="va">Gamma</span> <span class="op">=</span> <span class="fu"><a href="../reference/tpm_g.html">tpm_g</a></span><span class="op">(</span><span class="va">Z</span>, <span class="va">beta</span><span class="op">)</span> <span class="co"># covariate-dependent tpms (in this case only 24 unique)</span></span>
<span>  <span class="co"># tpm_g() automatically checks if intercept column is included</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">ADREPORT</a></span><span class="op">(</span><span class="va">Gamma</span><span class="op">)</span> <span class="co"># adreporting</span></span>
<span>  <span class="va">Delta</span> <span class="op">=</span> <span class="fu"><a href="../reference/stationary_p.html">stationary_p</a></span><span class="op">(</span><span class="va">Gamma</span><span class="op">)</span> <span class="co"># periodically stationary distribution</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">ADREPORT</a></span><span class="op">(</span><span class="va">Delta</span><span class="op">)</span></span>
<span>  <span class="va">delta</span> <span class="op">=</span> <span class="va">Delta</span><span class="op">[</span><span class="va">tod</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,<span class="op">]</span> <span class="co"># initial periodically stationary distribution</span></span>
<span>  <span class="co"># exponentiating because all parameters strictly positive</span></span>
<span>  <span class="va">mu</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">logmu</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">mu</span><span class="op">)</span></span>
<span>  <span class="va">sigma</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">logsigma</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">sigma</span><span class="op">)</span></span>
<span>  <span class="va">kappa</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">logkappa</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">kappa</span><span class="op">)</span></span>
<span>  <span class="co"># calculating all state-dependent densities</span></span>
<span>  <span class="va">allprobs</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fl">1</span>, nrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">step</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">N</span><span class="op">)</span></span>
<span>  <span class="va">ind</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/which.html" class="external-link">which</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">step</span><span class="op">)</span> <span class="op">&amp;</span> <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">angle</span><span class="op">)</span><span class="op">)</span> <span class="co"># only for non-NA obs.</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">N</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">allprobs</span><span class="op">[</span><span class="va">ind</span>,<span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="../reference/gamma2.html">dgamma2</a></span><span class="op">(</span><span class="va">step</span><span class="op">[</span><span class="va">ind</span><span class="op">]</span>,<span class="va">mu</span><span class="op">[</span><span class="va">j</span><span class="op">]</span>,<span class="va">sigma</span><span class="op">[</span><span class="va">j</span><span class="op">]</span><span class="op">)</span><span class="op">*</span><span class="fu"><a href="../reference/dvm.html">dvm</a></span><span class="op">(</span><span class="va">angle</span><span class="op">[</span><span class="va">ind</span><span class="op">]</span>,<span class="fl">0</span>,<span class="va">kappa</span><span class="op">[</span><span class="va">j</span><span class="op">]</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="op">-</span><span class="fu"><a href="../reference/forward_g.html">forward_g</a></span><span class="op">(</span><span class="va">delta</span>, <span class="va">Gamma</span><span class="op">[</span>,,<span class="va">tod</span><span class="op">]</span>, <span class="va">allprobs</span><span class="op">)</span> <span class="co"># indexing 24 unique tpms by tod in data</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>Having done this, the model fit is then essentially the same:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">obj2</span> <span class="op">=</span> <span class="fu">MakeADFun</span><span class="op">(</span><span class="va">nll2</span>, <span class="va">par</span>, silent <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="co"># creating the objective function</span></span>
<span><span class="va">opt2</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlminb.html" class="external-link">nlminb</a></span><span class="op">(</span><span class="va">obj2</span><span class="op">$</span><span class="va">par</span>, <span class="va">obj2</span><span class="op">$</span><span class="va">fn</span>, <span class="va">obj2</span><span class="op">$</span><span class="va">gr</span><span class="op">)</span> <span class="co"># optimization</span></span></code></pre></div>
<p>and we can look at the reported results. In this case, for simplicity
I get standard errors for <code>Gamma</code> with the delta method
while, in general, this is not advisable.</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mod2</span> <span class="op">=</span> <span class="va">obj2</span><span class="op">$</span><span class="fu">report</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="va">sdr</span> <span class="op">=</span> <span class="fu">sdreport</span><span class="op">(</span><span class="va">obj2</span><span class="op">)</span></span>
<span><span class="va">Gamma</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">as.list</a></span><span class="op">(</span><span class="va">sdr</span>, <span class="st">"Estimate"</span>, report <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">$</span><span class="va">Gamma</span></span>
<span><span class="va">Gammasd</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">as.list</a></span><span class="op">(</span><span class="va">sdr</span>, <span class="st">"Std"</span>, report <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">$</span><span class="va">Gamma</span></span>
<span></span>
<span><span class="va">Delta</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">as.list</a></span><span class="op">(</span><span class="va">sdr</span>, <span class="st">"Estimate"</span>, report <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">$</span><span class="va">Delta</span></span>
<span><span class="va">Deltasd</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">as.list</a></span><span class="op">(</span><span class="va">sdr</span>, <span class="st">"Std"</span>, report <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">$</span><span class="va">Delta</span></span>
<span></span>
<span><span class="va">tod_seq</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">24</span>, length <span class="op">=</span> <span class="fl">200</span><span class="op">)</span> <span class="co"># sequence for plotting</span></span>
<span><span class="va">Z_pred</span> <span class="op">=</span> <span class="fu"><a href="../reference/trigBasisExp.html">trigBasisExp</a></span><span class="op">(</span><span class="va">tod_seq</span>, degree <span class="op">=</span> <span class="fl">2</span><span class="op">)</span> <span class="co"># design matrix for prediction</span></span>
<span></span>
<span><span class="va">Gamma_plot</span> <span class="op">=</span> <span class="fu"><a href="../reference/tpm_g.html">tpm_g</a></span><span class="op">(</span><span class="va">Z_pred</span>, <span class="va">mod2</span><span class="op">$</span><span class="va">beta</span><span class="op">)</span> <span class="co"># interpolating transition probs</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">tod_seq</span>, <span class="va">Gamma_plot</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="op">]</span>, type <span class="op">=</span> <span class="st">"l"</span>, lwd <span class="op">=</span> <span class="fl">2</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1</span><span class="op">)</span>,</span>
<span>     xlab <span class="op">=</span> <span class="st">"time of day"</span>, ylab <span class="op">=</span> <span class="st">"transition probability"</span>, bty <span class="op">=</span> <span class="st">"n"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/segments.html" class="external-link">segments</a></span><span class="op">(</span>x0 <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">24</span>, y0 <span class="op">=</span> <span class="va">Gamma</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="op">]</span><span class="op">-</span><span class="fl">1.96</span><span class="op">*</span><span class="va">Gammasd</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="op">]</span>, </span>
<span>         y1 <span class="op">=</span> <span class="va">Gamma</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="op">]</span><span class="op">+</span><span class="fl">1.96</span><span class="op">*</span><span class="va">Gammasd</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="op">]</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/segments.html" class="external-link">segments</a></span><span class="op">(</span>x0 <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">24</span>, y0 <span class="op">=</span> <span class="va">Gamma</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span>,<span class="op">]</span><span class="op">-</span><span class="fl">1.96</span><span class="op">*</span><span class="va">Gammasd</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span>,<span class="op">]</span>, </span>
<span>         y1 <span class="op">=</span> <span class="va">Gamma</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span>,<span class="op">]</span><span class="op">+</span><span class="fl">1.96</span><span class="op">*</span><span class="va">Gammasd</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span>,<span class="op">]</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">tod_seq</span>, <span class="va">Gamma_plot</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span>,<span class="op">]</span>, lwd <span class="op">=</span> <span class="fl">2</span>, lty <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html" class="external-link">legend</a></span><span class="op">(</span><span class="st">"topleft"</span>, lwd <span class="op">=</span> <span class="fl">2</span>, lty <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">3</span><span class="op">)</span>, bty <span class="op">=</span> <span class="st">"n"</span>,</span>
<span>       legend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/expression.html" class="external-link">expression</a></span><span class="op">(</span><span class="va">gamma</span><span class="op">[</span><span class="fl">12</span><span class="op">]</span><span class="op">^</span><span class="op">(</span><span class="va">t</span><span class="op">)</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/expression.html" class="external-link">expression</a></span><span class="op">(</span><span class="va">gamma</span><span class="op">[</span><span class="fl">21</span><span class="op">]</span><span class="op">^</span><span class="op">(</span><span class="va">t</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="LaMa_and_RTMB_files/figure-html/MLE2-1.png" width="85%" style="display: block; margin: auto;"></p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">Delta</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span>, type <span class="op">=</span> <span class="st">"b"</span>, lwd <span class="op">=</span> <span class="fl">2</span>, xlab <span class="op">=</span> <span class="st">"time of day"</span>, ylab <span class="op">=</span> <span class="st">"Pr(active)"</span>, </span>
<span>     col <span class="op">=</span> <span class="st">"deepskyblue"</span>, bty <span class="op">=</span> <span class="st">"n"</span>, xaxt <span class="op">=</span> <span class="st">"n"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/segments.html" class="external-link">segments</a></span><span class="op">(</span>x0 <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">24</span>, y0 <span class="op">=</span> <span class="va">Delta</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span><span class="op">-</span><span class="fl">1.96</span><span class="op">*</span><span class="va">Deltasd</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span>, lwd <span class="op">=</span> <span class="fl">2</span>,</span>
<span>         y1 <span class="op">=</span> <span class="va">Delta</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span><span class="op">+</span><span class="fl">1.96</span><span class="op">*</span><span class="va">Deltasd</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span>, col <span class="op">=</span> <span class="st">"deepskyblue"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/axis.html" class="external-link">axis</a></span><span class="op">(</span><span class="fl">1</span>, at <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">24</span>,by<span class="op">=</span><span class="fl">4</span><span class="op">)</span>, labels <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">24</span>,by<span class="op">=</span><span class="fl">4</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="LaMa_and_RTMB_files/figure-html/MLE2-2.png" width="85%" style="display: block; margin: auto;"></p>
</div>
<div class="section level3">
<h3 id="penalized-splines">Penalized splines<a class="anchor" aria-label="anchor" href="#penalized-splines"></a>
</h3>
<p>We can go one step further and model the transition probabilities as
smooth functions of the time of day using cyclic P-splines, i.e.
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">logit</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>γ</mi><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mi>β</mi><mn>0</mn><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo>+</mo><msub><mi>s</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
\text{logit}(\gamma_{ij}^{(t)}) = \beta_0^{(ij)} + s_{ij}(t),
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">s_{ij}(t)</annotation></semantics></math>
is a smooth periodic function of time of day. <code>LaMa</code> provides
the function <code><a href="../reference/make_matrices.html">make_matrices()</a></code> which creates design and
penalty matrices based on the R package <code>mgcv</code> when provided
with a formula and data. Hence, we can use standard <code>mgcv</code>
syntax to create the matrices for cyclic P-splines (<code>cp</code>). We
then append both to the <code>dat</code> list.</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">modmat</span> <span class="op">=</span> <span class="fu"><a href="../reference/make_matrices.html">make_matrices</a></span><span class="op">(</span><span class="op">~</span> <span class="fu">s</span><span class="op">(</span><span class="va">tod</span>, bs <span class="op">=</span> <span class="st">"cp"</span><span class="op">)</span>, </span>
<span>                       data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>tod <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">24</span><span class="op">)</span>,</span>
<span>                       knots <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>tod <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">24</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="co"># where to wrap the cyclic basis</span></span>
<span><span class="va">Z</span> <span class="op">=</span> <span class="va">modmat</span><span class="op">$</span><span class="va">Z</span> <span class="co"># spline design matrix</span></span>
<span><span class="va">S</span> <span class="op">=</span> <span class="va">modmat</span><span class="op">$</span><span class="va">S</span> <span class="co"># penalty matrix</span></span>
<span><span class="va">dat</span><span class="op">$</span><span class="va">Z</span> <span class="op">=</span> <span class="va">Z</span></span>
<span><span class="va">dat</span><span class="op">$</span><span class="va">S</span> <span class="op">=</span> <span class="va">S</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="co"># mgcv returns a list of penalty matrices (even if only one smooth)</span></span></code></pre></div>
<p>We have to change our likelihood function slightly by adding the
penalization. For this we use the <code><a href="../reference/penalty.html">penalty()</a></code> function
contained in <code>LaMa</code> that computes the sum of quadratic form
penalties (the standard penalty used for penalized splines) based on the
penalty matrices, the parameters to be estimated and the penalty
strength parameters.</p>
<p>Importantly, we now have to separate the non-penalized intercept
<code>beta0</code> from the penalized spline coefficients now called
<code>betaspline</code>. The latter, we again conveniently initialize as
a matrix, each row representing the coefficient vector for one
off-diagonal element of the t.p.m.</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pnll</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">par</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">getAll</a></span><span class="op">(</span><span class="va">par</span>, <span class="va">dat</span><span class="op">)</span> <span class="co"># makes everything contained available without $</span></span>
<span>  <span class="va">Gamma</span> <span class="op">=</span> <span class="fu"><a href="../reference/tpm_g.html">tpm_g</a></span><span class="op">(</span><span class="va">Z</span>, <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">beta0</span>, <span class="va">betaspline</span><span class="op">)</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">ADREPORT</a></span><span class="op">(</span><span class="va">Gamma</span><span class="op">)</span></span>
<span>  <span class="va">Delta</span> <span class="op">=</span> <span class="fu"><a href="../reference/stationary_p.html">stationary_p</a></span><span class="op">(</span><span class="va">Gamma</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">ADREPORT</a></span><span class="op">(</span><span class="va">Delta</span><span class="op">)</span></span>
<span>  <span class="va">delta</span> <span class="op">=</span> <span class="va">Delta</span><span class="op">[</span><span class="va">tod</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,<span class="op">]</span></span>
<span>  <span class="co"># exponentiating because all parameters strictly positive</span></span>
<span>  <span class="va">mu</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">logmu</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">mu</span><span class="op">)</span></span>
<span>  <span class="va">sigma</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">logsigma</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">sigma</span><span class="op">)</span></span>
<span>  <span class="va">kappa</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">logkappa</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">kappa</span><span class="op">)</span></span>
<span>  <span class="co"># calculating all state-dependent densities</span></span>
<span>  <span class="va">allprobs</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fl">1</span>, nrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">step</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">N</span><span class="op">)</span></span>
<span>  <span class="va">ind</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/which.html" class="external-link">which</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">step</span><span class="op">)</span> <span class="op">&amp;</span> <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">angle</span><span class="op">)</span><span class="op">)</span> <span class="co"># only for non-NA obs.</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">N</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">allprobs</span><span class="op">[</span><span class="va">ind</span>,<span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="../reference/gamma2.html">dgamma2</a></span><span class="op">(</span><span class="va">step</span><span class="op">[</span><span class="va">ind</span><span class="op">]</span>,<span class="va">mu</span><span class="op">[</span><span class="va">j</span><span class="op">]</span>,<span class="va">sigma</span><span class="op">[</span><span class="va">j</span><span class="op">]</span><span class="op">)</span><span class="op">*</span><span class="fu"><a href="../reference/dvm.html">dvm</a></span><span class="op">(</span><span class="va">angle</span><span class="op">[</span><span class="va">ind</span><span class="op">]</span>,<span class="fl">0</span>,<span class="va">kappa</span><span class="op">[</span><span class="va">j</span><span class="op">]</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="op">-</span><span class="fu"><a href="../reference/forward_g.html">forward_g</a></span><span class="op">(</span><span class="va">delta</span>, <span class="va">Gamma</span><span class="op">[</span>,,<span class="va">tod</span><span class="op">]</span>, <span class="va">allprobs</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="../reference/penalty.html">penalty</a></span><span class="op">(</span><span class="va">betaspline</span>, <span class="va">S</span>, <span class="va">lambda</span><span class="op">)</span> <span class="co"># this does all the penalization work</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>We also have to append a <code>lambda</code> argument to our
<code>dat</code> list, which is the initial penalty strength parameter
vector. In this case of length two because our coefficient matrix has
two rows.</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">par</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>logmu <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.3</span>, <span class="fl">2.5</span><span class="op">)</span><span class="op">)</span>, </span>
<span>           logsigma <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">1.5</span><span class="op">)</span><span class="op">)</span>,</span>
<span>           logkappa <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">1.5</span><span class="op">)</span><span class="op">)</span>,</span>
<span>           beta0 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">)</span>, <span class="co"># intercept now separated!</span></span>
<span>           betaspline <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">2</span><span class="op">*</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">Z</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">dat</span><span class="op">$</span><span class="va">lambda</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">100</span>, <span class="fl">2</span><span class="op">)</span> <span class="co"># adding initial penalty strength to the dat list</span></span></code></pre></div>
<p>The model fit can then be conducted by using the <code><a href="../reference/qreml.html">qreml()</a></code>
function contained in <code>LaMa</code>. <strong>qREML</strong> stands
for <strong>quasi restricted maximum likelihood</strong> and finds a
good penalty strength by treating the spline coefficients as random
effects. Under the hood, <code><a href="../reference/qreml.html">qreml()</a></code> also constructs an AD
function with <code>RTMB</code> but uses the <strong>qREML</strong>
algorithm described in Koslik (2024) to fit the model. We have to tell
the <code><a href="../reference/qreml.html">qreml()</a></code> function which parameters are spline
coefficients by providing the name of the corresponding list element of
<code>par</code>.</p>
<p>There are some rules to follow when using <code><a href="../reference/qreml.html">qreml()</a></code>:</p>
<ol style="list-style-type: decimal">
<li>The likelihood function needs to be <code>RTMB</code>-compatible,
i.e. have the same structure as all the likelihood functions in our
vignette – most importantly, it should only be a function of the
parameter list.</li>
<li>The penalty strength vector <code>lambda</code> needs its length to
correspond to the <em>total</em> number of spline coefficient vectors
used. In our case, this is the number of rows of betaspline, but if we
additionally had a different spline coefficient in our parameter list
(that may have a different length and a different penalty matrix), we
would have needed more elements in <code>lambda</code>.</li>
<li>The <code><a href="../reference/penalty.html">penalty()</a></code> function can only be called <em>once</em>
in the likelihood. If several spline coefficients are penalized,
<code><a href="../reference/penalty.html">penalty()</a></code> expects a list of coefficient matrices or vectors
and a list of penalty matrices.</li>
<li>When we summarise multiple spline coefficients in a matrix in our
parameter list – which is very useful when these are of same lengths and
have the same penalty matrix – this matrix must be arranged by row,
i.e. each row is one spline coefficient vector. If it is arranged by
column, <code><a href="../reference/qreml.html">qreml()</a></code> will fail.</li>
</ol>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span></span>
<span>  <span class="va">mod3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/qreml.html">qreml</a></span><span class="op">(</span><span class="va">pnll</span>, <span class="va">par</span>, <span class="va">dat</span>, random <span class="op">=</span> <span class="st">"betaspline"</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; Creating AD function</span></span>
<span><span class="co">#&gt; Initializing with lambda: 100 100 </span></span>
<span><span class="co">#&gt; outer 1 - lambda: 5.844 3.811 </span></span>
<span><span class="co">#&gt; outer 2 - lambda: 0.781 0.969 </span></span>
<span><span class="co">#&gt; outer 3 - lambda: 0.289 0.363 </span></span>
<span><span class="co">#&gt; outer 4 - lambda: 0.205 0.179 </span></span>
<span><span class="co">#&gt; outer 5 - lambda: 0.184 0.115 </span></span>
<span><span class="co">#&gt; outer 6 - lambda: 0.178 0.092 </span></span>
<span><span class="co">#&gt; outer 7 - lambda: 0.176 0.083 </span></span>
<span><span class="co">#&gt; outer 8 - lambda: 0.175 0.079 </span></span>
<span><span class="co">#&gt; outer 9 - lambda: 0.175 0.078 </span></span>
<span><span class="co">#&gt; outer 10 - lambda: 0.175 0.078 </span></span>
<span><span class="co">#&gt; outer 11 - lambda: 0.175 0.078 </span></span>
<span><span class="co">#&gt; outer 12 - lambda: 0.175 0.078 </span></span>
<span><span class="co">#&gt; Converged</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   5.042   0.108   5.041</span></span></code></pre></div>
<p>The <code>mod</code> object is now a list that contains everything
that is reported by the likelihood function, but also the
<code>RTMB</code> object created in the process. After fitting the
model, we can also use the <code>LaMa</code> function
<code><a href="../reference/pred_matrix.html">pred_matrix()</a></code>, that takes the <code>modmat</code> object we
created earlier, to build a new interpolating design matrix using the
exact same basis expansion specified above. This allows us to plot the
estimated transition probabilities as a smooth function of time of day –
I now ignore confidence bands due to laziness.</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sdr</span> <span class="op">=</span> <span class="fu">sdreport</span><span class="op">(</span><span class="va">mod3</span><span class="op">$</span><span class="va">obj</span><span class="op">)</span></span>
<span><span class="va">Gamma</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">as.list</a></span><span class="op">(</span><span class="va">sdr</span>, <span class="st">"Estimate"</span>, report <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">$</span><span class="va">Gamma</span></span>
<span><span class="va">Delta</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">as.list</a></span><span class="op">(</span><span class="va">sdr</span>, <span class="st">"Estimate"</span>, report <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">$</span><span class="va">Delta</span></span>
<span></span>
<span><span class="va">tod_seq</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">24</span>, length<span class="op">=</span><span class="fl">200</span><span class="op">)</span></span>
<span><span class="va">Z_pred</span> <span class="op">=</span> <span class="fu"><a href="../reference/pred_matrix.html">pred_matrix</a></span><span class="op">(</span><span class="va">modmat</span>, <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>tod <span class="op">=</span> <span class="va">tod_seq</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">Gamma_plot</span> <span class="op">=</span> <span class="fu"><a href="../reference/tpm_g.html">tpm_g</a></span><span class="op">(</span><span class="va">Z_pred</span>, <span class="va">mod3</span><span class="op">$</span><span class="va">beta</span><span class="op">)</span> <span class="co"># interpolating transition probs</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">tod_seq</span>, <span class="va">Gamma_plot</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="op">]</span>, type <span class="op">=</span> <span class="st">"l"</span>, lwd <span class="op">=</span> <span class="fl">2</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1</span><span class="op">)</span>,</span>
<span>     xlab <span class="op">=</span> <span class="st">"time of day"</span>, ylab <span class="op">=</span> <span class="st">"transition probability"</span>, bty <span class="op">=</span> <span class="st">"n"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">tod_seq</span>, <span class="va">Gamma_plot</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span>,<span class="op">]</span>, lwd <span class="op">=</span> <span class="fl">2</span>, lty <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html" class="external-link">legend</a></span><span class="op">(</span><span class="st">"topleft"</span>, lwd <span class="op">=</span> <span class="fl">2</span>, lty <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">3</span><span class="op">)</span>, bty <span class="op">=</span> <span class="st">"n"</span>,</span>
<span>       legend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/expression.html" class="external-link">expression</a></span><span class="op">(</span><span class="va">gamma</span><span class="op">[</span><span class="fl">12</span><span class="op">]</span><span class="op">^</span><span class="op">(</span><span class="va">t</span><span class="op">)</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/expression.html" class="external-link">expression</a></span><span class="op">(</span><span class="va">gamma</span><span class="op">[</span><span class="fl">21</span><span class="op">]</span><span class="op">^</span><span class="op">(</span><span class="va">t</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="LaMa_and_RTMB_files/figure-html/results%20qreml-1.png" width="85%" style="display: block; margin: auto;"></p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">Delta</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span>, type <span class="op">=</span> <span class="st">"b"</span>, lwd <span class="op">=</span> <span class="fl">2</span>, xlab <span class="op">=</span> <span class="st">"time of day"</span>, ylab <span class="op">=</span> <span class="st">"Pr(active)"</span>, </span>
<span>     col <span class="op">=</span> <span class="st">"deepskyblue"</span>, bty <span class="op">=</span> <span class="st">"n"</span>, xaxt <span class="op">=</span> <span class="st">"n"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/axis.html" class="external-link">axis</a></span><span class="op">(</span><span class="fl">1</span>, at <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">24</span>,by<span class="op">=</span><span class="fl">4</span><span class="op">)</span>, labels <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">24</span>,by<span class="op">=</span><span class="fl">4</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="LaMa_and_RTMB_files/figure-html/results%20qreml-2.png" width="85%" style="display: block; margin: auto;"></p>
<p>We see that by allowing for a more flexible relationship, the
estimated time of day effect becomes stronger with even sharper peaks
than we would have concluded using the trigonometric approach.</p>
</div>
<div class="section level3">
<h3 id="full-laplace-method">Full Laplace method<a class="anchor" aria-label="anchor" href="#full-laplace-method"></a>
</h3>
<p>Lastly, we could have achieved a similar fit as above using the
slightly more accurate full Laplace approximation method, which can be
used to fit models via marginal maximum likelihood estimation by
integrating out the random effects. This is natively supported by
<code>RTMB</code> – and actually one of its core selling points – and
the standard way we can now deal with all kinds of random effects.</p>
<p>Indeed, the <strong>qREML</strong> algorithm above treats the spline
coefficients as Gaussian random effects but exploits their relatively
simple structure yiedling a more efficient fitting method. The full
Laplace method is much more general, allowing for very flexible random
effects, but here, estimation slower because it does not exploit the
simple structure of splines treated as random effects.</p>
<p>We have to alter our likelihood function slightly, because for the
Laplace method, we need to implement the joint likelihood of the data
and the random effect, the latter having a multivariate normal
distribution. Specifically, if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
is our random effect for a spline,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msup><mi>λ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msup><mi>S</mi><mo>−</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">b \sim N(0, \lambda^{-1} S^-)</annotation></semantics></math>.
The likelihood of the data given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
(just our regular likelihoot that treats
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
as a parameter) is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>∣</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(x \mid b)</annotation></semantics></math>
and the density of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>λ</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f_{\lambda}(b)</annotation></semantics></math>.
Hence the joint likelihood can be computed as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>∣</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>f</mi><mi>λ</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
f(x, b) = f(x \mid b) f_{\lambda}(b)
</annotation></semantics></math> and the joint negative log-likelihood
becomes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mo>log</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>∣</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mo>log</mo><msub><mi>f</mi><mi>λ</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">- \log f(x \mid b) - \log f_{\lambda}(b)</annotation></semantics></math>
and this is what we implement below.</p>
<p>Most conveniently this is done by using the <code><a href="../reference/dgmrf2.html">dgmrf2()</a></code>
function included in <code>LaMa</code> which provides the density
function of the multivariate normal distribution reparametrized in terms
of the (scaled) precision matrix, i.e. inverse covariance matrix, which
in our case is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub><mi>S</mi></mrow><annotation encoding="application/x-tex">\lambda_i S</annotation></semantics></math>
for spline
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>.
It allows evaluating at multiple points at once, each one possibly with
its own penalty strength parameter <code>lambda</code>. It differs from
<code>RTMB</code>’s <code><a href="https://rdrr.io/pkg/RTMB/man/MVgauss.html" class="external-link">dgmrf()</a></code> by not expecting a
<em>sparse</em> precision matrix and being more robust for
rank-deficient penalty matrices, which are typical for penalized
splines.</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">jnll</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">par</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">getAll</a></span><span class="op">(</span><span class="va">par</span>, <span class="va">dat</span><span class="op">)</span> <span class="co"># makes everything contained available without $</span></span>
<span>  <span class="va">Gamma</span> <span class="op">=</span> <span class="fu"><a href="../reference/tpm_g.html">tpm_g</a></span><span class="op">(</span><span class="va">Z</span>, <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">beta0</span>, <span class="va">betaspline</span><span class="op">)</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">ADREPORT</a></span><span class="op">(</span><span class="va">Gamma</span><span class="op">)</span></span>
<span>  <span class="va">Delta</span> <span class="op">=</span> <span class="fu"><a href="../reference/stationary_p.html">stationary_p</a></span><span class="op">(</span><span class="va">Gamma</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">ADREPORT</a></span><span class="op">(</span><span class="va">Delta</span><span class="op">)</span></span>
<span>  <span class="va">delta</span> <span class="op">=</span> <span class="va">Delta</span><span class="op">[</span><span class="va">tod</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,<span class="op">]</span></span>
<span>  <span class="co"># exponentiating because all parameters strictly positive</span></span>
<span>  <span class="va">mu</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">logmu</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">mu</span><span class="op">)</span></span>
<span>  <span class="va">sigma</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">logsigma</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">sigma</span><span class="op">)</span></span>
<span>  <span class="va">kappa</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">logkappa</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">kappa</span><span class="op">)</span></span>
<span>  <span class="co"># calculating all state-dependent densities</span></span>
<span>  <span class="va">allprobs</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fl">1</span>, nrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">step</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">N</span><span class="op">)</span></span>
<span>  <span class="va">ind</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/which.html" class="external-link">which</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">step</span><span class="op">)</span> <span class="op">&amp;</span> <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">angle</span><span class="op">)</span><span class="op">)</span> <span class="co"># only for non-NA obs.</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">N</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">allprobs</span><span class="op">[</span><span class="va">ind</span>,<span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="../reference/gamma2.html">dgamma2</a></span><span class="op">(</span><span class="va">step</span><span class="op">[</span><span class="va">ind</span><span class="op">]</span>,<span class="va">mu</span><span class="op">[</span><span class="va">j</span><span class="op">]</span>,<span class="va">sigma</span><span class="op">[</span><span class="va">j</span><span class="op">]</span><span class="op">)</span><span class="op">*</span><span class="fu"><a href="../reference/dvm.html">dvm</a></span><span class="op">(</span><span class="va">angle</span><span class="op">[</span><span class="va">ind</span><span class="op">]</span>,<span class="fl">0</span>,<span class="va">kappa</span><span class="op">[</span><span class="va">j</span><span class="op">]</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="op">-</span><span class="fu"><a href="../reference/forward_g.html">forward_g</a></span><span class="op">(</span><span class="va">delta</span>, <span class="va">Gamma</span><span class="op">[</span>,,<span class="va">tod</span><span class="op">]</span>, <span class="va">allprobs</span><span class="op">)</span> <span class="op">-</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="fu"><a href="../reference/dgmrf2.html">dgmrf2</a></span><span class="op">(</span><span class="va">betaspline</span>, <span class="fl">0</span>, <span class="va">S</span>, <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">loglambda</span><span class="op">)</span>, log <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span> <span class="co"># just like any other density in R</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>We also have to include the log of our penalty strength as a
parameter now.</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">par</span><span class="op">$</span><span class="va">loglambda</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">100</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>To create the objective function, we need to tell <code>RTMB</code>
that <code>betaspline</code> is a random effect such that it is
integrated out and as our objective function we have the marginal
likelihood
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>∫</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mi>d</mi><mi>b</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">
f(x) = \int f(x, b) \,db,
</annotation></semantics></math> actually its negative log of
course.</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">obj4</span> <span class="op">=</span> <span class="fu">MakeADFun</span><span class="op">(</span><span class="va">jnll</span>, <span class="va">par</span>, random <span class="op">=</span> <span class="st">"betaspline"</span>, silent <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span></span>
<span>  <span class="va">opt4</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlminb.html" class="external-link">nlminb</a></span><span class="op">(</span><span class="va">obj4</span><span class="op">$</span><span class="va">par</span>, <span class="va">obj4</span><span class="op">$</span><span class="va">fn</span>, <span class="va">obj4</span><span class="op">$</span><span class="va">gr</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>This more general algorithm takes more than ten times model as long
to fit the model. Hence, the above code is not evaluated. The results
however are very similar.</p>
<!-- ```{r results refit, fig.width = 8, fig.height = 5}
mod4 = obj4$report()
mod4$Gamma = tpm_g(Z, mod4$beta) # calculating 24 tpms

Gamma_plot = tpm_g(Z_pred, mod4$beta)
plot(tod_seq, Gamma_plot[1,2,], type = "l", lwd = 2, ylim = c(0,1),
     xlab = "time of day", ylab = "transition probability", bty = "n")
lines(tod_seq, Gamma_plot[2,1,], lwd = 2, lty = 3)
legend("topleft", lwd = 2, lty = c(1,3), bty = "n",
       legend = c(expression(gamma[12]^(t)), expression(gamma[21]^(t))))
``` -->
</div>
<div class="section level3">
<h3 id="common-issues-with-rtmb">Common issues with <code>RTMB</code><a class="anchor" aria-label="anchor" href="#common-issues-with-rtmb"></a>
</h3>
<p>There are some problems with <code>RTMB</code> one has to keep in
mind. They can be a bit annoying, but in my opinion the benefits of
automatic differentiation far outweigh the drawbacks. I list the main
ones I have encountered here, but please tell me if you encounter more,
such that they can be added.</p>
<p>A typical issue with <code>RTMB</code> is that some operators might
need to be overloaded to allow for automatic differentiation which
cannot be done by default. In typical model setups <code>LaMa</code>
functions do this themselves, but if you go a very individualistic route
and get an error like</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/stop.html" class="external-link">stop</a></span><span class="op">(</span><span class="st">"Invalid argument to 'advector' (lost class attribute?)"</span><span class="op">)</span></span></code></pre></div>
<p>you might have to overload the operator yourself. To do this put</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="st">"[&lt;-"</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/ADoverload.html" class="external-link">ADoverload</a></span><span class="op">(</span><span class="st">"[&lt;-"</span><span class="op">)</span></span></code></pre></div>
<p>as the first line of your likelihood function. If the error still
prevails also add</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="st">"c"</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/ADoverload.html" class="external-link">ADoverload</a></span><span class="op">(</span><span class="st">"c"</span><span class="op">)</span></span>
<span><span class="st">"diag&lt;-"</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/ADoverload.html" class="external-link">ADoverload</a></span><span class="op">(</span><span class="st">"diag&lt;-"</span><span class="op">)</span></span></code></pre></div>
<p>which should hopefully fix the error.</p>
<p>Another common problem occurs when initiating objects with
<code>NA</code> values and then trying to fill them with
<code>numeric</code> values. This is because <code>NA</code> is logical
which screws up the automatic differentiation due to the mismatching
types. To avoid this, always initiate with <code>numeric</code> or
<code>NaN</code> values. For example, don’t do</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">X</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/array.html" class="external-link">array</a></span><span class="op">(</span>dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co"># which is the same as</span></span>
<span><span class="va">X</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/array.html" class="external-link">array</a></span><span class="op">(</span><span class="cn">NA</span>, dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>but rather</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">X</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/array.html" class="external-link">array</a></span><span class="op">(</span><span class="cn">NaN</span>, dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co"># or</span></span>
<span><span class="va">X</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/array.html" class="external-link">array</a></span><span class="op">(</span><span class="fl">0</span>, dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>to avoid the error.</p>
<p>Furthermore, there are some unfortunate side effects of R’s ‘byte
compiler’ (enabled by default in R). So if you encounter an error not
matching the previous ones, try disabling the byte compiler with</p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">compiler</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/compiler/compile.html" class="external-link">enableJIT</a></span><span class="op">(</span><span class="fl">0</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 3</span></span></code></pre></div>
<p>and see if the error is resolved.</p>
<p>Some more minor things:</p>
<ul>
<li>if you’re used to <code>expm::expm()</code> that won’t work with AD.
Use <code><a href="https://rdrr.io/pkg/Matrix/man/expm-methods.html" class="external-link">Matrix::expm()</a></code> instead.</li>
<li>
<code>CircStats::dvm()</code> also isn’t compatible with AD. Use
<code><a href="../reference/dvm.html">LaMa::dvm()</a></code> instead.</li>
<li>you can use <code>if</code> statements in your likelihood function,
but <em>not</em> on the parameter itself as this will obviously not be
differentiable.</li>
<li>most of the standard distributions are available in
<code>RTMB</code>. If you need a non-standard one, try implementing the
density function yourself using plain R code. <code>RTMB</code> also
provides AD versions of many building-block functions (like the Gamma or
Bessel function) which might help with this.</li>
</ul>
<p>For more information on <code>RTMB</code>, check out its <a href="https://cran.r-project.org/web/packages/RTMB/index.html" class="external-link">documentation</a>
or the <a href="https://groups.google.com/g/tmb-users" class="external-link">TMB users Google
group</a>.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Jan-Ole Koslik.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
