"0","mllk_muskox = function(theta.star, step, N, agsizes){"
"0","  # parameter transformation from working to natural"
"0","  mu = exp(theta.star[1:N]) # step mean"
"0","  sigma = exp(theta.star[N+1:N]) # step standard deviation"
"0","  mu_dwell = exp(theta.star[2*N+1:N]) # dwell time mean"
"0","  phi = exp(theta.star[3*N+1:N]) # dwell time dispersion"
"0","  if(N>2){ "
"0","    # conditional transition probability matrix"
"0","    omega = matrix(0,N,N)"
"0","    omega[!diag(N)] = as.vector(t(matrix(c(rep(1,N),"
"0","                          exp(theta.star[4*N+1:(N*(N-2))])),N,N-1)))"
"0","    omega = t(omega)/apply(omega,2,sum)"
"0","  } else{ omega = matrix(c(0,1,1,0),2,2) }"
"0","  dm = list() # list of dwell-time distributions"
"0","  for(j in 1:N){ "
"0","    # R allows to parametrize by mean and size where size = 1/dispersion"
"0","    dm[[j]] = dnbinom(1:agsizes[j]-1, mu=mu_dwell[j], size=1/phi[j]) "
"0","  }"
"0","  Gamma = LaMa::tpm_hsmm(omega, dm)"
"0","  delta = LaMa::stationary(Gamma)"
"0","  allprobs = matrix(1, length(step), N)"
"0","  ind = which(!is.na(step))"
"0","  for(j in 1:N){"
"0","    # we reparametrise the gamma distribution in terms of mean and sd"
"0","    allprobs[ind,j] = dgamma(step[ind], shape = mu[j]^2 / sigma[j]^2, "
"0","                             scale = sigma[j]^2 / mu[j])"
"0","  }"
"0","  -LaMa::forward_s(delta, Gamma, allprobs, agsizes)"
"0","}"
