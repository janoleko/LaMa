"0","mllk = function(theta.star, y, bm, m){"
"0","  phi = plogis(theta.star[1])"
"0","  sigma = exp(theta.star[2])"
"0","  beta = exp(theta.star[3])"
"0","  b = seq(-bm, bm, length = m+1) # intervals for midpoint quadrature"
"0","  h = b[2]-b[1] # interval width"
"0","  bstar = (b[-1] + b[-(m+1)])/2 # interval midpoints"
"0","  # approximation resulting from midpoint quadrature"
"0","  Gamma = sapply(bstar, dnorm, mean = phi*bstar, sd = sigma) * h"
"0","  Gamma = Gamma / rowSums(Gamma) # normalizing out approximation errors"
"0","  delta = h * dnorm(bstar, 0, sigma/sqrt(1-phi^2)) # stationary distribution"
"0","  # approximating state-dependent density based on midpoints"
"0","  allprobs = t(sapply(y, dnorm, mean = 0, sd = beta * exp(bstar/2)))"
"0","  # return negative for minimization"
"0","  -forward(delta, Gamma, allprobs)"
"0","}"
