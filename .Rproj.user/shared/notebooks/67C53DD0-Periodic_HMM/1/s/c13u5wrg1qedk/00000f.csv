"0","mllk_np = function(theta.star, x, z, Z, lambda){"
"0","  beta = matrix(theta.star[1:(2+2*nk)], nrow = 2) # nk params per off-diagonal element"
"0","  Gamma = tpm_p(tod = 1:48, L = 48, beta = beta, Z = Z) # calculating all L tpms"
"0","  delta = stationary_p(Gamma, t = z[1]) # periodically stationary HMM"
"0","  mu = theta.star[2+2*nk + 1:2]"
"0","  sigma = exp(theta.star[2+2*nk + 2 + 1:2])"
"0","  # calculate all state-dependent probabilities"
"0","  allprobs = matrix(1, length(x), 2)"
"0","  for(j in 1:2){ allprobs[,j] = stats::dnorm(x, mu[j], sigma[j]) }"
"0","  # return negative for minimization"
"0","  l = forward_p(delta, Gamma, allprobs, z)"
"0","  # penalize curvature"
"0","  penalty = sum(diff(beta[1,-1], differences = 2)^2)+"
"0","    sum(diff(beta[2,-1], differences = 2)^2)"
"0","  return(-l + lambda*penalty)"
"0","}"
