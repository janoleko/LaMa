<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Penalised splines • LaMa</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Penalised splines">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">LaMa</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">2.0.5</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/Continuous_time_HMMs.html">Continuous-time HMMs</a></li>
    <li><a class="dropdown-item" href="../articles/HSMMs.html">Hidden semi-Markov models</a></li>
    <li><a class="dropdown-item" href="../articles/Inhomogeneous_HMMs.html">Inhomogeneous HMMs</a></li>
    <li><a class="dropdown-item" href="../articles/Intro_to_LaMa.html">Introduction to LaMa</a></li>
    <li><a class="dropdown-item" href="../articles/LaMa_and_RTMB.html">LaMa and RTMB</a></li>
    <li><a class="dropdown-item" href="../articles/Longitudinal_data.html">Longitudinal data</a></li>
    <li><a class="dropdown-item" href="../articles/MMMPPs.html">Markov-modulated (marked) Poisson processes</a></li>
    <li><a class="dropdown-item" href="../articles/Penalised_splines.html">Penalised splines</a></li>
    <li><a class="dropdown-item" href="../articles/Periodic_HMMs.html">Periodic HMMs</a></li>
    <li><a class="dropdown-item" href="../articles/State_space_models.html">State-space models</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Penalised splines</h1>
            
      

      <div class="d-none name"><code>Penalised_splines.Rmd</code></div>
    </div>

    
    
<!-- *Before reading this vignette, it is advised that you read the vignettes "Introduction to LaMa", "Inhomogeneous HMMs", "periodic HMMs" and "LaMa and RTMB".* -->
<blockquote>
<p>Before diving into this vignette, we recommend reading the vignettes
<strong>Introduction to LaMa</strong>, <strong>Inhomogeneous
HMMs</strong>, <strong>Periodic HMMs</strong> and <strong>LaMa and
RTMB</strong>.</p>
</blockquote>
<p>This vignette explores how <code>LaMa</code> can be used to fit
models involving nonparameteric components, represented by
<strong>penalised splines</strong>. The main idea here is that it may be
useful to represent some relationships in our model by smooth functions
for which the functional form is not pre-specified, but flexibly
estimated from the data. For HMM-like models, this is particularly
valuable, as the latent nature of the state process makes modelling
choices more difficult. For example, choosing an appropriate parametric
family for the state-dependent distributions may be difficult as we
cannot do state-specific EDA before fitting the model. Also very
difficult is the dependence of transition probabilities on covariates as
the transitions are not directly observed. Hence, the obvious
alternative is to model these kind of relationships flexibly using
splines but imposing a penalty on the smoothness of the estimated
functions. This leads us to <strong>penalised splines</strong>.</p>
<p><code>LaMa</code> contains helper functions that build
<strong>design</strong> and <strong>penalty matrices</strong> for given
formulas (using <code>mgcv</code> under the hood) and also functions to
estimate models involving penalised splines in a random effects
framework. For the latter to work, the <strong>penalised negative
log-likelihood</strong> needs to be compatible with the R package
<code>RTMB</code> to allow for <strong>automatic differentiation
(AD)</strong>. For more information on <code>RTMB</code>, see the
vignette <em>LaMa and RTMB</em> or check out its <a href="https://CRAN.R-project.org/package=RTMB" class="external-link">documentation</a>. For
more information on penalised splines, we recommend <span class="citation">Wood (<a href="#ref-wood2017generalized">2017</a>)</span>.</p>
<div class="section level3">
<h3 id="smooth-transition-probabilites">Smooth transition probabilites<a class="anchor" aria-label="anchor" href="#smooth-transition-probabilites"></a>
</h3>
<p>We will start by investigating a 2-state HMM for the
<code>trex</code> data set, containing hourly step lengths and turning
angles of a Tyrannosaurus rex living 66 million years ago. The
transition probabilities are modelled as smooth functions of the time of
day using <strong>cyclic P-Splines</strong>. The relationship can be
summarised as</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">logit</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>γ</mi><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mi>β</mi><mn>0</mn><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo>+</mo><msub><mi>s</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
\text{logit}(\gamma_{ij}^{(t)}) = \beta_0^{(ij)} + s_{ij}(t),
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">s_{ij}(t)</annotation></semantics></math>
is a smooth periodic function of time of day. We model the T-rex’s
<strong>step lengths</strong> and <strong>turning angles</strong> using
state-dependent <strong>gamma</strong> and <strong>von Mises</strong>
distributions.</p>
<p>To ease with model specification, <code>LaMa</code> provides the
function <code><a href="../reference/make_matrices.html">make_matrices()</a></code> which creates
<strong>design</strong> and <strong>penalty</strong> matrices for
regression settings based on the R package <code>mgcv</code>. The user
only needs to specify the right side of a formula using
<code>mgcv</code> syntax and provide data. Here, we use
<code>s(tod, by = "cp")</code> to create the matrices for cyclic
P-splines (<code>cp</code>). This results in a cubic B-Spline basis,
that is wrapped at boundary of the support (0 and 24). We then append
both resulting matrices to the <code>dat</code> list.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://janoleko.github.io/LaMa/">LaMa</a></span><span class="op">)</span></span>
<span><span class="co">#&gt; Loading required package: RTMB</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">trex</span><span class="op">)</span></span>
<span><span class="co">#&gt;   tod      step     angle state</span></span>
<span><span class="co">#&gt; 1   9 0.3252437        NA     1</span></span>
<span><span class="co">#&gt; 2  10 0.2458265  2.234562     1</span></span>
<span><span class="co">#&gt; 3  11 0.2173252 -2.262418     1</span></span>
<span><span class="co">#&gt; 4  12 0.5114665 -2.958732     1</span></span>
<span><span class="co">#&gt; 5  13 0.3828494  1.811840     1</span></span>
<span><span class="co">#&gt; 6  14 0.4220099  1.834668     1</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">modmat</span> <span class="op">=</span> <span class="fu"><a href="../reference/make_matrices.html">make_matrices</a></span><span class="op">(</span><span class="op">~</span> <span class="fu">s</span><span class="op">(</span><span class="va">tod</span>, bs <span class="op">=</span> <span class="st">"cp"</span><span class="op">)</span>, <span class="co"># formula</span></span>
<span>                       data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>tod <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">24</span><span class="op">)</span>, <span class="co"># data</span></span>
<span>                       knots <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>tod <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">24</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="co"># where to wrap the cyclic basis</span></span>
<span><span class="va">Z</span> <span class="op">=</span> <span class="va">modmat</span><span class="op">$</span><span class="va">Z</span> <span class="co"># spline design matrix</span></span>
<span><span class="va">S</span> <span class="op">=</span> <span class="va">modmat</span><span class="op">$</span><span class="va">S</span> <span class="co"># penalty matrix</span></span></code></pre></div>
<p>We can now specify the <strong>penalised negative log-likelihood
function</strong>. The transition probability matrix can be computed the
regular way using <code><a href="../reference/tpm_g.html">tpm_g()</a></code>. In the last line we need to add
the curvature penalty based on <code>S</code>, which we can conveniently
do using <code><a href="../reference/penalty.html">penalty()</a></code>.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pnll</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">par</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">getAll</a></span><span class="op">(</span><span class="va">par</span>, <span class="va">dat</span><span class="op">)</span></span>
<span>  <span class="co"># cbinding intercept and spline coefs, because intercept is not penalised</span></span>
<span>  <span class="va">Gamma</span> <span class="op">=</span> <span class="fu"><a href="../reference/tpm_g.html">tpm_g</a></span><span class="op">(</span><span class="va">Z</span>, <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">beta0</span>, <span class="va">betaSpline</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="co"># computing all periodically stationary distributions for easy access later</span></span>
<span>  <span class="va">Delta</span> <span class="op">=</span> <span class="fu"><a href="../reference/stationary_p.html">stationary_p</a></span><span class="op">(</span><span class="va">Gamma</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">Delta</span><span class="op">)</span></span>
<span>  <span class="co"># parameter transformations</span></span>
<span>  <span class="va">mu</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">logmu</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">mu</span><span class="op">)</span></span>
<span>  <span class="va">sigma</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">logsigma</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">sigma</span><span class="op">)</span></span>
<span>  <span class="va">kappa</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">logkappa</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">kappa</span><span class="op">)</span></span>
<span>  <span class="co"># calculating all state-dependent densities</span></span>
<span>  <span class="va">allprobs</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fl">1</span>, nrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">step</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">N</span><span class="op">)</span></span>
<span>  <span class="va">ind</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/which.html" class="external-link">which</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">step</span><span class="op">)</span> <span class="op">&amp;</span> <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">angle</span><span class="op">)</span><span class="op">)</span> <span class="co"># only for non-NA obs.</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">N</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">allprobs</span><span class="op">[</span><span class="va">ind</span>,<span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="../reference/gamma2.html">dgamma2</a></span><span class="op">(</span><span class="va">step</span><span class="op">[</span><span class="va">ind</span><span class="op">]</span>,<span class="va">mu</span><span class="op">[</span><span class="va">j</span><span class="op">]</span>,<span class="va">sigma</span><span class="op">[</span><span class="va">j</span><span class="op">]</span><span class="op">)</span> <span class="op">*</span> <span class="fu"><a href="../reference/vm.html">dvm</a></span><span class="op">(</span><span class="va">angle</span><span class="op">[</span><span class="va">ind</span><span class="op">]</span>,<span class="fl">0</span>,<span class="va">kappa</span><span class="op">[</span><span class="va">j</span><span class="op">]</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="op">-</span><span class="fu"><a href="../reference/forward_g.html">forward_g</a></span><span class="op">(</span><span class="va">Delta</span><span class="op">[</span><span class="va">tod</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,<span class="op">]</span>, <span class="va">Gamma</span><span class="op">[</span>,,<span class="va">tod</span><span class="op">]</span>, <span class="va">allprobs</span><span class="op">)</span> <span class="op">+</span> <span class="co"># regular forward algorithm</span></span>
<span>    <span class="fu"><a href="../reference/penalty.html">penalty</a></span><span class="op">(</span><span class="va">betaSpline</span>, <span class="va">S</span>, <span class="va">lambda</span><span class="op">)</span> <span class="co"># this does all the penalisation work</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>We also have to append a <code>lambda</code> vector to our
<code>dat</code> list which is the <strong>initial penalty
strength</strong> parameter vector. In this case it is of length two
because our coefficient matrix has two rows.</p>
<p>If you are wondering why <code>lambda</code> is not added to the
<code>par</code> list, this is because for penalised likelihood
estimation, it is a <strong>hyperparameter</strong>, hence not a true
parameter in the sense of the other parameters in <code>par</code>. One
could, at his point, just use the above penalised likelihood function to
do penalised ML for a <strong>fixed</strong> penalty strength
<code>lambda</code>.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">par</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>logmu <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.3</span>, <span class="fl">2.5</span><span class="op">)</span><span class="op">)</span>, <span class="co"># state-dependent mean step</span></span>
<span>           logsigma <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">1.5</span><span class="op">)</span><span class="op">)</span>, <span class="co"># state-dependent sd step</span></span>
<span>           logkappa <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">1.5</span><span class="op">)</span><span class="op">)</span>, <span class="co"># state-dependent concentration angle</span></span>
<span>           beta0 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">)</span>, <span class="co"># state process intercepts</span></span>
<span>           betaSpline <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">2</span><span class="op">*</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">Z</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span> <span class="co"># spline coefs</span></span>
<span></span>
<span><span class="va">dat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>step <span class="op">=</span> <span class="va">trex</span><span class="op">$</span><span class="va">step</span>, <span class="co"># observed steps</span></span>
<span>           angle <span class="op">=</span> <span class="va">trex</span><span class="op">$</span><span class="va">angle</span>, <span class="co"># observed angle</span></span>
<span>           N <span class="op">=</span> <span class="fl">2</span>, <span class="co"># number of states</span></span>
<span>           tod <span class="op">=</span> <span class="va">trex</span><span class="op">$</span><span class="va">tod</span>, <span class="co"># time of day (used for indexing)</span></span>
<span>           Z <span class="op">=</span> <span class="va">Z</span>, <span class="co"># spline design matrix</span></span>
<span>           S <span class="op">=</span> <span class="va">S</span>, <span class="co"># penalty matrix</span></span>
<span>           lambda <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">100</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span> <span class="co"># initial penalty strength</span></span></code></pre></div>
<p>The model fit with automatic smoothness selection can then be
conducted by using the <code><a href="../reference/qreml.html">qreml()</a></code> function contained in
<code>LaMa</code>. The <strong>quasi restricted maximum
likelihood</strong> algorithm finds a good penalty strength parameter
<code>lambda</code> by treating the spline coefficients as random
effects. Under the hood, <code><a href="../reference/qreml.html">qreml()</a></code> also constructs an AD
function with <code>RTMB</code> but uses the <strong>qREML</strong>
algorithm <span class="citation">(<a href="#ref-koslik2024efficient">Koslik 2024</a>)</span> to fit the
model. We have to tell the <code><a href="../reference/qreml.html">qreml()</a></code> function which
parameters are spline coefficients by providing the name of the
corresponding list element of <code>par</code>.</p>
<p>There are some rules to follow when using <code><a href="../reference/qreml.html">qreml()</a></code>:</p>
<ol style="list-style-type: decimal">
<li><p>The likelihood function needs to be <code>RTMB</code>-compatible,
i.e. have the same structure as the likelihood functions in the vignette
<em>LaMa and RTMB</em>. Most importantly, it should be a function of the
parameter list only.</p></li>
<li><p>The penalty strength vector <code>lambda</code> needs its length
to correspond to the <em>total</em> number of spline coefficient vectors
used. In our case, this is the number of rows of
<code>betaSpline</code>, but if we additionally had a different spline
coefficient (with a different name) in our parameter list, possibly with
a different length and a different penalty matrix, we would have needed
more elements in <code>lambda</code>.</p></li>
<li><p>The <code><a href="../reference/penalty.html">penalty()</a></code> function can only be called
<em>once</em> in the likelihood. If several spline coefficients are
penalised, <code><a href="../reference/penalty.html">penalty()</a></code> expects a list of coefficient matrices
or vectors and a list of penalty matrices. This is shown in the third
example in this vignette.</p></li>
</ol>
<!-- 5. When we summarise multiple spline coefficients in a matrix in our parameter list -- which is very useful when these are of same lengths and have the same penalty matrix -- this matrix must be arranged **by row**, i.e. each row is one spline coefficient vector. If it is arranged by column, `qreml()` will fail. --><ol start="4" style="list-style-type: decimal">
<li>By default, <code><a href="../reference/qreml.html">qreml()</a></code> assumes that the penalisation
hyperparameter in the <code>dat</code> object is called
<code>lambda</code>. You can use a different name for <code>dat</code>
(of course than changing it in your <code>pnll</code> as well), but if
you want to use a different name for the penalisation hyperparameter,
you have to specify it as a character string in the <code><a href="../reference/qreml.html">qreml()</a></code>
call using the <code>psname</code> argument.</li>
</ol>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span></span>
<span>  <span class="va">mod1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/qreml.html">qreml</a></span><span class="op">(</span><span class="va">pnll</span>, <span class="va">par</span>, <span class="va">dat</span>, random <span class="op">=</span> <span class="st">"betaSpline"</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; Creating AD function</span></span>
<span><span class="co">#&gt; Initialising with lambda: 100 100 </span></span>
<span><span class="co">#&gt; outer 1 - lambda: 32.051 31.828 </span></span>
<span><span class="co">#&gt; outer 2 - lambda: 10.555 10.748 </span></span>
<span><span class="co">#&gt; outer 3 - lambda: 3.659 3.977 </span></span>
<span><span class="co">#&gt; outer 4 - lambda: 1.41 1.589 </span></span>
<span><span class="co">#&gt; outer 5 - lambda: 0.669 0.693 </span></span>
<span><span class="co">#&gt; outer 6 - lambda: 0.426 0.347 </span></span>
<span><span class="co">#&gt; outer 7 - lambda: 0.346 0.21 </span></span>
<span><span class="co">#&gt; outer 8 - lambda: 0.32 0.153 </span></span>
<span><span class="co">#&gt; outer 9 - lambda: 0.312 0.129 </span></span>
<span><span class="co">#&gt; outer 10 - lambda: 0.309 0.119 </span></span>
<span><span class="co">#&gt; outer 11 - lambda: 0.308 0.116 </span></span>
<span><span class="co">#&gt; Converged</span></span>
<span><span class="co">#&gt; Final model fit with lambda: 0.308 0.116</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;  11.565   3.211  11.155</span></span></code></pre></div>
<p>The <code>mod</code> object is now a list that contains everything
that is reported by the likelihood function, but also the
<code>RTMB</code> object created in the process. After fitting the
model, we can use <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> with the <code>modmat</code>
object we created earlier to build a new interpolating design matrix
using the exact same basis expansion specified above. This allows us to
plot the estimated transition probabilities as a smooth function of time
of day.
<!-- Uncertainty quantification can be based on the Hessian of the penalised likelihood function, returned as `Hessian_conditional` in the `mod` object. To easily relist the sampled parameter vector to the original named-list structure, the function `relist_par()` is contained in the `mod` object. --></p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">Delta</span> <span class="op">=</span> <span class="va">mod1</span><span class="op">$</span><span class="va">Delta</span></span>
<span></span>
<span><span class="va">tod_seq</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">24</span>, length <span class="op">=</span> <span class="fl">100</span><span class="op">)</span></span>
<span><span class="va">Z_p</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">modmat</span>, <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>tod <span class="op">=</span> <span class="va">tod_seq</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">Gamma_plot</span> <span class="op">=</span> <span class="fu"><a href="../reference/tpm_g.html">tpm_g</a></span><span class="op">(</span><span class="va">Z_p</span>, <span class="va">mod1</span><span class="op">$</span><span class="va">beta</span><span class="op">)</span> <span class="co"># interpolating transition probs</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">tod_seq</span>, <span class="va">Gamma_plot</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="op">]</span>, type <span class="op">=</span> <span class="st">"l"</span>, lwd <span class="op">=</span> <span class="fl">2</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1</span><span class="op">)</span>,</span>
<span>     xlab <span class="op">=</span> <span class="st">"time of day"</span>, ylab <span class="op">=</span> <span class="st">"transition probability"</span>, bty <span class="op">=</span> <span class="st">"n"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">tod_seq</span>, <span class="va">Gamma_plot</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span>,<span class="op">]</span>, lwd <span class="op">=</span> <span class="fl">2</span>, lty <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html" class="external-link">legend</a></span><span class="op">(</span><span class="st">"topleft"</span>, lwd <span class="op">=</span> <span class="fl">2</span>, lty <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">3</span><span class="op">)</span>, bty <span class="op">=</span> <span class="st">"n"</span>,</span>
<span>       legend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/expression.html" class="external-link">expression</a></span><span class="op">(</span><span class="va">gamma</span><span class="op">[</span><span class="fl">12</span><span class="op">]</span><span class="op">^</span><span class="op">(</span><span class="va">t</span><span class="op">)</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/expression.html" class="external-link">expression</a></span><span class="op">(</span><span class="va">gamma</span><span class="op">[</span><span class="fl">21</span><span class="op">]</span><span class="op">^</span><span class="op">(</span><span class="va">t</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="Penalised_splines_files/figure-html/results%20qreml-1.png" width="85%" style="display: block; margin: auto;"></p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">Delta</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span>, type <span class="op">=</span> <span class="st">"b"</span>, lwd <span class="op">=</span> <span class="fl">2</span>, pch <span class="op">=</span> <span class="fl">16</span>, xlab <span class="op">=</span> <span class="st">"time of day"</span>, ylab <span class="op">=</span> <span class="st">"Pr(active)"</span>, </span>
<span>     col <span class="op">=</span> <span class="st">"deepskyblue"</span>, bty <span class="op">=</span> <span class="st">"n"</span>, xaxt <span class="op">=</span> <span class="st">"n"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/axis.html" class="external-link">axis</a></span><span class="op">(</span><span class="fl">1</span>, at <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">24</span>,by<span class="op">=</span><span class="fl">4</span><span class="op">)</span>, labels <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">24</span>,by<span class="op">=</span><span class="fl">4</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="Penalised_splines_files/figure-html/results%20qreml-2.png" width="85%" style="display: block; margin: auto;"></p>
</div>
<div class="section level3">
<h3 id="smooth-density-estimation">Smooth density estimation<a class="anchor" aria-label="anchor" href="#smooth-density-estimation"></a>
</h3>
<p>To demonstrate nonparametric estimation of the state-dependent
densities, we will consider the <code>nessi</code> data set. It contains
acceleration data of the Loch Ness Monster, specifically the
<strong>overall dynamic body acceleration (ODBA)</strong>. ODBA is
strictily positive with some very extreme values, making direct analysis
difficult. Hence, for our analysis we consider the logarithm of ODBA as
our observed process.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">nessi</span><span class="op">)</span></span>
<span><span class="co">#&gt;         ODBA   logODBA state</span></span>
<span><span class="co">#&gt; 1 0.03775025 -3.276763     2</span></span>
<span><span class="co">#&gt; 2 0.05417830 -2.915475     2</span></span>
<span><span class="co">#&gt; 3 0.03625247 -3.317248     2</span></span>
<span><span class="co">#&gt; 4 0.01310802 -4.334531     1</span></span>
<span><span class="co">#&gt; 5 0.05402441 -2.918319     3</span></span>
<span><span class="co">#&gt; 6 0.06133794 -2.791357     3</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">nessi</span><span class="op">$</span><span class="va">logODBA</span>, prob <span class="op">=</span> <span class="cn">TRUE</span>, breaks <span class="op">=</span> <span class="fl">50</span>, bor <span class="op">=</span> <span class="st">"white"</span>, </span>
<span>     main <span class="op">=</span> <span class="st">""</span>, xlab <span class="op">=</span> <span class="st">"log(ODBA)"</span><span class="op">)</span></span></code></pre></div>
<p><img src="Penalised_splines_files/figure-html/shark_data-1.png" width="85%" style="display: block; margin: auto;"></p>
<p>Clearly, there are at least three behavioural states in the data, and
we start by fitting a simple 3-state Gaussian HMM with likelihood
function:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nll</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">par</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">getAll</a></span><span class="op">(</span><span class="va">par</span>, <span class="va">dat</span><span class="op">)</span></span>
<span>    <span class="va">sigma</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">logsigma</span><span class="op">)</span> <span class="co"># exp because strictly positive</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">mu</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">sigma</span><span class="op">)</span></span>
<span>    <span class="va">Gamma</span> <span class="op">=</span> <span class="fu"><a href="../reference/tpm.html">tpm</a></span><span class="op">(</span><span class="va">eta</span><span class="op">)</span> <span class="co"># multinomial logit link</span></span>
<span>    <span class="va">delta</span> <span class="op">=</span> <span class="fu"><a href="../reference/stationary.html">stationary</a></span><span class="op">(</span><span class="va">Gamma</span><span class="op">)</span> <span class="co"># stationary dist of the homogeneous Markov chain</span></span>
<span>    <span class="va">allprobs</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">logODBA</span><span class="op">)</span>, <span class="va">N</span><span class="op">)</span></span>
<span>    <span class="va">ind</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/which.html" class="external-link">which</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">logODBA</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">N</span><span class="op">)</span> <span class="va">allprobs</span><span class="op">[</span><span class="va">ind</span>,<span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">dnorm</a></span><span class="op">(</span><span class="va">logODBA</span><span class="op">[</span><span class="va">ind</span><span class="op">]</span>, <span class="va">mu</span><span class="op">[</span><span class="va">j</span><span class="op">]</span>, <span class="va">sigma</span><span class="op">[</span><span class="va">j</span><span class="op">]</span><span class="op">)</span></span>
<span>    <span class="op">-</span><span class="fu"><a href="../reference/forward.html">forward</a></span><span class="op">(</span><span class="va">delta</span>, <span class="va">Gamma</span>, <span class="va">allprobs</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>We then fit the model as explained in the vignette <em>LaMa and
RTMB</em>.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># initial parameter list</span></span>
<span><span class="va">par</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>mu <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">4.5</span>, <span class="op">-</span><span class="fl">3.5</span>, <span class="op">-</span><span class="fl">2.5</span><span class="op">)</span>,</span>
<span>           logsigma <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0.5</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span>,</span>
<span>           eta <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>, <span class="fl">6</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># data and hyperparameters</span></span>
<span><span class="va">dat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>logODBA <span class="op">=</span> <span class="va">nessi</span><span class="op">$</span><span class="va">logODBA</span>, N <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># creating automatically differentiable objective function</span></span>
<span><span class="va">obj</span> <span class="op">=</span> <span class="fu">MakeADFun</span><span class="op">(</span><span class="va">nll</span>, <span class="va">par</span>, silent <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># fitting the model</span></span>
<span><span class="va">opt</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlminb.html" class="external-link">nlminb</a></span><span class="op">(</span><span class="va">obj</span><span class="op">$</span><span class="va">par</span>, <span class="va">obj</span><span class="op">$</span><span class="va">fn</span>, <span class="va">obj</span><span class="op">$</span><span class="va">gr</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># reporting to get calculated quantities</span></span>
<span><span class="va">mod</span> <span class="op">=</span> <span class="va">obj</span><span class="op">$</span><span class="fu">report</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># visualising the results</span></span>
<span><span class="va">color</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"orange"</span>, <span class="st">"deepskyblue"</span>, <span class="st">"seagreen3"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">nessi</span><span class="op">$</span><span class="va">logODBA</span>, prob <span class="op">=</span> <span class="cn">TRUE</span>, breaks <span class="op">=</span> <span class="fl">50</span>, bor <span class="op">=</span> <span class="st">"white"</span>,</span>
<span>     main <span class="op">=</span> <span class="st">""</span>, xlab <span class="op">=</span> <span class="st">"log(ODBA)"</span><span class="op">)</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/graphics/curve.html" class="external-link">curve</a></span><span class="op">(</span><span class="va">mod</span><span class="op">$</span><span class="va">delta</span><span class="op">[</span><span class="va">j</span><span class="op">]</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">dnorm</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">mod</span><span class="op">$</span><span class="va">mu</span><span class="op">[</span><span class="va">j</span><span class="op">]</span>, <span class="va">mod</span><span class="op">$</span><span class="va">sigma</span><span class="op">[</span><span class="va">j</span><span class="op">]</span><span class="op">)</span>, </span>
<span>                    add <span class="op">=</span> <span class="cn">TRUE</span>, col <span class="op">=</span> <span class="va">color</span><span class="op">[</span><span class="va">j</span><span class="op">]</span>, lwd <span class="op">=</span> <span class="fl">2</span>, n <span class="op">=</span> <span class="fl">500</span><span class="op">)</span></span></code></pre></div>
<p><img src="Penalised_splines_files/figure-html/Gaussian%20fit-1.png" width="85%" style="display: block; margin: auto;"></p>
<p>We see a clear lack-of-fit due to the inflexibility of the Gaussian
state-dependent densities. Thus, we now fit a model with state-dependent
densities based on P-Splines.</p>
<p>In a first step, this requires us to prepare the
<strong>design</strong> and <strong>penalty matrices</strong> needed
using <code><a href="../reference/smooth_dens_construct.html">smooth_dens_construct()</a></code>. This function can take
multiple data streams and a set of initial parameters (specifying
initial means and standard deviations) for each data stream. It then
builds the <strong>P-Spline</strong> design and penalty matrices for
each data stream as well as a matrix of <strong>initial spline
coefficients</strong> based on the provided parameters. The basis
functions are standardised such that they integrate to one, which is
needed for density estimation.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># providing initial means and sds to initialise spline coefficients</span></span>
<span><span class="va">par0</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>logODBA <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>mean <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">4</span>, <span class="op">-</span><span class="fl">3.3</span>, <span class="op">-</span><span class="fl">2.8</span><span class="op">)</span>, sd <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.3</span>, <span class="fl">0.2</span>, <span class="fl">0.5</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># construct the smooth density objects</span></span>
<span><span class="va">modmat</span> <span class="op">=</span> <span class="fu"><a href="../reference/smooth_dens_construct.html">smooth_dens_construct</a></span><span class="op">(</span><span class="va">nessi</span><span class="op">[</span><span class="st">"logODBA"</span><span class="op">]</span>, <span class="co"># only one data stream here</span></span>
<span>                               par <span class="op">=</span> <span class="va">par0</span><span class="op">)</span></span>
<span><span class="co">#&gt; logODBA </span></span>
<span><span class="co">#&gt; Leaving out last column of the penalty matrix, fix the last spline coefficient at zero for identifiability!</span></span>
<span><span class="co">#&gt; Parameter matrix excludes the last column. Add a (fixed) zero column using 'cbind(coef, 0)' in your loss function!</span></span>
<span></span>
<span><span class="co"># par is nested named list: top layer: each data stream</span></span>
<span><span class="co"># for each data stream: initial means and standard deviations for each state</span></span>
<span></span>
<span><span class="co"># objects for model fitting</span></span>
<span><span class="va">Z</span> <span class="op">=</span> <span class="va">modmat</span><span class="op">$</span><span class="va">Z</span><span class="op">$</span><span class="va">logODBA</span> <span class="co"># spline design matrix for logODBA</span></span>
<span><span class="va">S</span> <span class="op">=</span> <span class="va">modmat</span><span class="op">$</span><span class="va">S</span><span class="op">$</span><span class="va">logODBA</span> <span class="co"># penalty matrix for logODBA</span></span>
<span><span class="va">beta</span> <span class="op">=</span> <span class="va">modmat</span><span class="op">$</span><span class="va">coef</span><span class="op">$</span><span class="va">logODBA</span> <span class="co"># initial spline coefficients</span></span>
<span></span>
<span><span class="co"># objects for prediction</span></span>
<span><span class="va">Z_p</span> <span class="op">=</span> <span class="va">modmat</span><span class="op">$</span><span class="va">Z_predict</span><span class="op">$</span><span class="va">logODBA</span> <span class="co"># prediction design matrix</span></span>
<span><span class="va">xseq</span> <span class="op">=</span> <span class="va">modmat</span><span class="op">$</span><span class="va">xseq</span><span class="op">$</span><span class="va">logODBA</span> <span class="co"># prediction sequence of logODBA values</span></span></code></pre></div>
<p>Then, we can specify the penalised negative log-likelihood function.
The six lines in the middle are needed for P-Spline-based density
estimation. The coefficient matrix <code>beta</code> provided by
<code>buildSmoothDens()</code> has one column less than the number of
basis functions, which is also printed when calling
<code>buildSmoothDens()</code>. This is because the last column,
i.e. the last coefficient for each state, needs to be fixed to zero for
<strong>identifiability</strong> which we do by using
<code>cbind(beta, 0)</code>. Then, we transform the unconstrained
parameter matrix to non-negative weights that sum to one (called
<code>alpha</code>) for each state using the inverse multinomial
logistic link (softmax). The columnns of the <code>allprobs</code>
matrix are then computed as linear combinations of the columns of
<code>Z</code> and the weights <code>alpha</code>. Lastly, we penalise
the unconstrained coefficients <code>beta</code> (not the constrained
<code>alpha</code>’s) using the <code><a href="../reference/penalty.html">penalty()</a></code> function.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pnll</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">par</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">getAll</a></span><span class="op">(</span><span class="va">par</span>, <span class="va">dat</span><span class="op">)</span></span>
<span>  <span class="co"># regular stationary HMM stuff</span></span>
<span>  <span class="va">Gamma</span> <span class="op">=</span> <span class="fu"><a href="../reference/tpm.html">tpm</a></span><span class="op">(</span><span class="va">eta</span><span class="op">)</span></span>
<span>  <span class="va">delta</span> <span class="op">=</span> <span class="fu"><a href="../reference/stationary.html">stationary</a></span><span class="op">(</span><span class="va">Gamma</span><span class="op">)</span></span>
<span>  <span class="co"># smooth state-dependent densities</span></span>
<span>  <span class="va">alpha</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">beta</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">alpha</span> <span class="op">=</span> <span class="va">alpha</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">rowSums</a></span><span class="op">(</span><span class="va">alpha</span><span class="op">)</span> <span class="co"># multinomial logit link</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">alpha</span><span class="op">)</span></span>
<span>  <span class="va">allprobs</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">Z</span><span class="op">)</span>, <span class="va">N</span><span class="op">)</span></span>
<span>  <span class="va">ind</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/which.html" class="external-link">which</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">Z</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span><span class="op">)</span><span class="op">)</span> <span class="co"># only for non-NA obs.</span></span>
<span>  <span class="va">allprobs</span><span class="op">[</span><span class="va">ind</span>,<span class="op">]</span> <span class="op">=</span> <span class="va">Z</span><span class="op">[</span><span class="va">ind</span>,<span class="op">]</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">alpha</span><span class="op">)</span></span>
<span>  <span class="co"># forward algorithm + penalty</span></span>
<span>  <span class="op">-</span><span class="fu"><a href="../reference/forward.html">forward</a></span><span class="op">(</span><span class="va">delta</span>, <span class="va">Gamma</span>, <span class="va">allprobs</span><span class="op">)</span> <span class="op">+</span> </span>
<span>    <span class="fu"><a href="../reference/penalty.html">penalty</a></span><span class="op">(</span><span class="va">beta</span>, <span class="va">S</span>, <span class="va">lambda</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>Now we specify the initial parameter and data list and fit the model.
In this case, we actually don’t need to add the observations to our
<code>dat</code> list anymore, as all the information is contained in
the design matrix <code>Z</code>.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">par</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>beta <span class="op">=</span> <span class="va">beta</span>, <span class="co"># spline coefficients prepared by smooth_dens_construct()</span></span>
<span>           eta <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>, <span class="fl">6</span><span class="op">)</span><span class="op">)</span> <span class="co"># initial transition matrix on logit scale</span></span>
<span></span>
<span><span class="va">dat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>N <span class="op">=</span> <span class="fl">3</span>, <span class="co"># number of states</span></span>
<span>           Z <span class="op">=</span> <span class="va">Z</span>, <span class="co"># spline design matrix</span></span>
<span>           S <span class="op">=</span> <span class="va">S</span>, <span class="co"># spline penalty matrix</span></span>
<span>           lambda <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">10</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span> <span class="co"># initial penalty strength vector</span></span>
<span></span>
<span><span class="co"># fitting the model using qREML</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span></span>
<span>  <span class="va">mod2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/qreml.html">qreml</a></span><span class="op">(</span><span class="va">pnll</span>, <span class="va">par</span>, <span class="va">dat</span>, random <span class="op">=</span> <span class="st">"beta"</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; Creating AD function</span></span>
<span><span class="co">#&gt; Initialising with lambda: 10 10 10 </span></span>
<span><span class="co">#&gt; outer 1 - lambda: 4.213 3.833 4.836 </span></span>
<span><span class="co">#&gt; outer 2 - lambda: 2.309 1.937 3.045 </span></span>
<span><span class="co">#&gt; outer 3 - lambda: 1.604 1.332 2.338 </span></span>
<span><span class="co">#&gt; outer 4 - lambda: 1.305 1.127 2.028 </span></span>
<span><span class="co">#&gt; outer 5 - lambda: 1.166 1.053 1.883 </span></span>
<span><span class="co">#&gt; outer 6 - lambda: 1.099 1.026 1.812 </span></span>
<span><span class="co">#&gt; outer 7 - lambda: 1.065 1.016 1.777 </span></span>
<span><span class="co">#&gt; outer 8 - lambda: 1.048 1.012 1.76 </span></span>
<span><span class="co">#&gt; outer 9 - lambda: 1.04 1.01 1.75 </span></span>
<span><span class="co">#&gt; outer 10 - lambda: 1.035 1.01 1.747 </span></span>
<span><span class="co">#&gt; outer 11 - lambda: 1.034 1.01 1.745 </span></span>
<span><span class="co">#&gt; outer 12 - lambda: 1.033 1.01 1.745 </span></span>
<span><span class="co">#&gt; outer 13 - lambda: 1.033 1.01 1.744 </span></span>
<span><span class="co">#&gt; Converged</span></span>
<span><span class="co">#&gt; Final model fit with lambda: 1.033 1.01 1.744</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;  17.569   4.413  16.886</span></span></code></pre></div>
<p>After fitting the model, we can easily visualise the smooth densities
using the prepared prediction objects. We already have access to all
reported quanitites because <code><a href="../reference/qreml.html">qreml()</a></code> automatically runs the
reporting after model fitting.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sDens</span> <span class="op">=</span> <span class="va">Z_p</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">mod2</span><span class="op">$</span><span class="va">alpha</span><span class="op">)</span> <span class="co"># all three state-dependent densities on a grid</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">nessi</span><span class="op">$</span><span class="va">logODBA</span>, prob <span class="op">=</span> <span class="cn">TRUE</span>, breaks <span class="op">=</span> <span class="fl">50</span>, bor <span class="op">=</span> <span class="st">"white"</span>, main <span class="op">=</span> <span class="st">""</span>, xlab <span class="op">=</span> <span class="st">"log(ODBA)"</span><span class="op">)</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">xseq</span>, <span class="va">mod2</span><span class="op">$</span><span class="va">delta</span><span class="op">[</span><span class="va">j</span><span class="op">]</span> <span class="op">*</span> <span class="va">sDens</span><span class="op">[</span>,<span class="va">j</span><span class="op">]</span>, col <span class="op">=</span> <span class="va">color</span><span class="op">[</span><span class="va">j</span><span class="op">]</span>, lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">xseq</span>, <span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">colSums</a></span><span class="op">(</span><span class="va">mod2</span><span class="op">$</span><span class="va">delta</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">sDens</span><span class="op">)</span><span class="op">)</span>, col <span class="op">=</span> <span class="st">"black"</span>, lwd <span class="op">=</span> <span class="fl">2</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="Penalised_splines_files/figure-html/shark_smooth_results-1.png" width="85%" style="display: block; margin: auto;"></p>
<p>The P-Spline model results in a very good fit to the empirical
distribution. This is beause the first state has a skewed distribution,
the second state has a high kurtosis and the third state has a funny
right tail. The P-Spline model can capture all of these features where
the parametric model failed to do so.</p>
</div>
<div class="section level3">
<h3 id="markov-switching-gamlss">Markov-switching GAMLSS<a class="anchor" aria-label="anchor" href="#markov-switching-gamlss"></a>
</h3>
<p>Lastly, we want to demonstrate how one can easily fit
Markov-switching regression models where the state-dependent means and
potentially other parameters depend on covariates via smooth functions.
For this, we consider the <code>energy</code> data set contained in the
R package <code>MSwM</code>. It comprises 1784 daily observations of
energy prices (in Cents per kWh) in Spain which we want to explain using
the daily oil prices (in Euros per barrel) also provided in the data.
Specifically, we consider a 2-state MS-GAMLSS defined by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">price</mtext><mi>t</mi></msub><mo>∣</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>S</mi><mi>t</mi></msub><mo>=</mo><mi>i</mi><mo stretchy="false" form="postfix">}</mo><mo>∼</mo><mi>N</mi><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><msubsup><mi>μ</mi><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo>,</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>σ</mi><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">
\text{price}_t \mid \{ S_t = i \} \sim N \bigl(\mu_t^{(i)}, (\sigma_t^{(i)})^2 \bigr),
</annotation></semantics></math><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>μ</mi><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo>=</mo><msubsup><mi>β</mi><mrow><mn>0</mn><mo>,</mo><mi>μ</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo>+</mo><msubsup><mi>s</mi><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mtext mathvariant="normal">oil</mtext><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mtext mathvariant="normal">log</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>σ</mi><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mi>β</mi><mrow><mn>0</mn><mo>,</mo><mi>σ</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo>+</mo><msubsup><mi>s</mi><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mtext mathvariant="normal">oil</mtext><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo></mrow><annotation encoding="application/x-tex">
\mu_t^{(i)} = \beta_{0,\mu}^{(i)} + s_{\mu}^{(i)}(\text{oil}_t), \quad \text{log}(\sigma_t^{(i)}) = \beta_{0, \sigma}^{(i)} + s_{\sigma}^{(i)}(\text{oil}_t), \quad i = 1,2,
</annotation></semantics></math> not covering other potential
explanatory covariates for the sake of simplicity.</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="va">energy</span>, package <span class="op">=</span> <span class="st">"MSwM"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">energy</span><span class="op">)</span></span>
<span><span class="co">#&gt;      Price      Oil      Gas     Coal   EurDol Ibex35   Demand</span></span>
<span><span class="co">#&gt; 1 3.188083 22.43277 14.40099 38.35157 1.134687 8.3976 477.3856</span></span>
<span><span class="co">#&gt; 2 4.953667 22.27263 19.02747 38.35157 1.106439 8.3771 609.1261</span></span>
<span><span class="co">#&gt; 3 4.730917 22.65383 18.48417 38.35157 1.106684 8.5547 650.3715</span></span>
<span><span class="co">#&gt; 4 4.531000 23.67657 18.30143 38.35157 1.116819 8.4631 647.0499</span></span>
<span><span class="co">#&gt; 5 5.141875 23.67209 14.55602 38.35157 1.122965 8.1773 627.9698</span></span>
<span><span class="co">#&gt; 6 6.322083 23.60534 15.22485 38.35157 1.122460 8.1866 693.2467</span></span></code></pre></div>
<p>Similar to the first example, we can prepare the model matrices using
<code><a href="../reference/make_matrices.html">make_matrices()</a></code>:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">modmat</span> <span class="op">=</span> <span class="fu"><a href="../reference/make_matrices.html">make_matrices</a></span><span class="op">(</span><span class="op">~</span> <span class="fu">s</span><span class="op">(</span><span class="va">Oil</span>, k <span class="op">=</span> <span class="fl">12</span>, bs <span class="op">=</span> <span class="st">"ps"</span><span class="op">)</span>, <span class="va">energy</span><span class="op">)</span></span>
<span><span class="va">Z</span> <span class="op">=</span> <span class="va">modmat</span><span class="op">$</span><span class="va">Z</span> <span class="co"># design matrix</span></span>
<span><span class="va">S</span> <span class="op">=</span> <span class="va">modmat</span><span class="op">$</span><span class="va">S</span> <span class="co"># penalty matrix (list)</span></span></code></pre></div>
<p>Then, we specify the penalised negative log-likelihood function. It
differs from the first example as the state-dependent distributions, as
opposed to the state process parameters, depend on the covariate.
Additionally, we now have two completely separated spline-coefficient
matrices/ random effects called <code>betaSpline</code> and
<code>alphaSpline</code> for the state-dependent means and standard
deviations respectively. Thus, we need to pass them as a list to the
<code><a href="../reference/penalty.html">penalty()</a></code> function.</p>
<p>We also pass the penalty matrix list <code>S</code> that is provided
by <code><a href="../reference/make_matrices.html">make_matrices()</a></code>. This could potentially be a list of
length two if the two spline coefficient matrices were penalised
differently (e.g. by us using a different spline basis). In this case,
however, they are the same and we only pass the list of length one. It
does not matter to <code><a href="../reference/penalty.html">penalty()</a></code> if we pass a list of length
one or just one matrix.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pnll</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">par</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">getAll</a></span><span class="op">(</span><span class="va">par</span>, <span class="va">dat</span><span class="op">)</span></span>
<span>  <span class="va">Gamma</span> <span class="op">=</span> <span class="fu"><a href="../reference/tpm.html">tpm</a></span><span class="op">(</span><span class="va">eta</span><span class="op">)</span> <span class="co"># computing the tpm</span></span>
<span>  <span class="va">delta</span> <span class="op">=</span> <span class="fu"><a href="../reference/stationary.html">stationary</a></span><span class="op">(</span><span class="va">Gamma</span><span class="op">)</span> <span class="co"># stationary distribution</span></span>
<span></span>
<span>  <span class="co"># regression parameters for mean and sd</span></span>
<span>  <span class="va">beta</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">beta0</span>, <span class="va">betaSpline</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">beta</span><span class="op">)</span> <span class="co"># mean parameter matrix</span></span>
<span>  <span class="va">alpha</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">alpha0</span>, <span class="va">alphaSpline</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/pkg/RTMB/man/TMB-interface.html" class="external-link">REPORT</a></span><span class="op">(</span><span class="va">alpha</span><span class="op">)</span> <span class="co"># sd parameter matrix</span></span>
<span></span>
<span>  <span class="co"># calculating all covariate-dependent means and sds</span></span>
<span>  <span class="va">Mu</span> <span class="op">=</span> <span class="va">Z</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">beta</span><span class="op">)</span> <span class="co"># mean</span></span>
<span>  <span class="va">Sigma</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">Z</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">alpha</span><span class="op">)</span><span class="op">)</span> <span class="co"># sd</span></span>
<span></span>
<span>  <span class="va">allprobs</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">dnorm</a></span><span class="op">(</span><span class="va">price</span>, <span class="va">Mu</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span>, <span class="va">Sigma</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span><span class="op">)</span>,</span>
<span>                   <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">dnorm</a></span><span class="op">(</span><span class="va">price</span>, <span class="va">Mu</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span>, <span class="va">Sigma</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span><span class="op">)</span><span class="op">)</span> <span class="co"># state-dependent densities</span></span>
<span>  </span>
<span>  <span class="op">-</span> <span class="fu"><a href="../reference/forward.html">forward</a></span><span class="op">(</span><span class="va">delta</span>, <span class="va">Gamma</span>, <span class="va">allprobs</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="../reference/penalty.html">penalty</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">betaSpline</span>, <span class="va">alphaSpline</span><span class="op">)</span>, <span class="va">S</span>, <span class="va">lambda</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>From this point on, the model fit is now basically identical to the
previous two examples. We specify initial parameters and include an
inital penalty strength parameter in the <code>dat</code> list.</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># initial parameter list</span></span>
<span><span class="va">par</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>eta <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="op">-</span><span class="fl">4</span>, <span class="fl">2</span><span class="op">)</span>, <span class="co"># state process intercepts</span></span>
<span>           beta0 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">5</span><span class="op">)</span>, <span class="co"># state-dependent mean intercepts</span></span>
<span>           betaSpline <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fl">0</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">11</span><span class="op">)</span>, <span class="co"># mean spline coef</span></span>
<span>           alpha0 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span>, <span class="co"># state-dependent sd intercepts</span></span>
<span>           alphaSpline <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fl">0</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">11</span><span class="op">)</span><span class="op">)</span> <span class="co"># sd spline coef</span></span>
<span></span>
<span><span class="co"># data, model matrices and initial penalty strength</span></span>
<span><span class="va">dat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>price <span class="op">=</span> <span class="va">energy</span><span class="op">$</span><span class="va">Price</span>, </span>
<span>           Z <span class="op">=</span> <span class="va">Z</span>, </span>
<span>           S <span class="op">=</span> <span class="va">S</span>, </span>
<span>           lambda <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1e3</span>, <span class="fl">4</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># model fit</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/system.time.html" class="external-link">system.time</a></span><span class="op">(</span></span>
<span>  <span class="va">mod3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/qreml.html">qreml</a></span><span class="op">(</span><span class="va">pnll</span>, <span class="va">par</span>, <span class="va">dat</span>, random <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"betaSpline"</span>, <span class="st">"alphaSpline"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; Creating AD function</span></span>
<span><span class="co">#&gt; Initialising with lambda: 1000 1000 1000 1000 </span></span>
<span><span class="co">#&gt; outer 1 - lambda: 466.896 374.247 432.358 329.654 </span></span>
<span><span class="co">#&gt; outer 2 - lambda: 250.283 143.698 200.372 113.051 </span></span>
<span><span class="co">#&gt; outer 3 - lambda: 126.064 57.828 99.173 42.157 </span></span>
<span><span class="co">#&gt; outer 4 - lambda: 72.846 26.191 56.901 18.27 </span></span>
<span><span class="co">#&gt; outer 5 - lambda: 48.019 14.491 35.924 9.766 </span></span>
<span><span class="co">#&gt; outer 6 - lambda: 35.991 10.081 24.159 6.518 </span></span>
<span><span class="co">#&gt; outer 7 - lambda: 29.871 8.365 17.317 5.192 </span></span>
<span><span class="co">#&gt; outer 8 - lambda: 26.631 7.684 13.359 4.626 </span></span>
<span><span class="co">#&gt; outer 9 - lambda: 24.863 7.41 11.104 4.375 </span></span>
<span><span class="co">#&gt; outer 10 - lambda: 23.88 7.297 9.836 4.263 </span></span>
<span><span class="co">#&gt; outer 11 - lambda: 23.325 7.25 9.13 4.213 </span></span>
<span><span class="co">#&gt; outer 12 - lambda: 23.007 7.23 8.74 4.189 </span></span>
<span><span class="co">#&gt; outer 13 - lambda: 22.822 7.22 8.525 4.178 </span></span>
<span><span class="co">#&gt; outer 14 - lambda: 22.719 7.216 8.406 4.173 </span></span>
<span><span class="co">#&gt; outer 15 - lambda: 22.655 7.214 8.342 4.171 </span></span>
<span><span class="co">#&gt; outer 16 - lambda: 22.618 7.213 8.305 4.17 </span></span>
<span><span class="co">#&gt; outer 17 - lambda: 22.598 7.213 8.286 4.169 </span></span>
<span><span class="co">#&gt; outer 18 - lambda: 22.589 7.212 8.279 4.169 </span></span>
<span><span class="co">#&gt; outer 19 - lambda: 22.588 7.212 8.277 4.169 </span></span>
<span><span class="co">#&gt; Converged</span></span>
<span><span class="co">#&gt; Final model fit with lambda: 22.588 7.212 8.277 4.169</span></span>
<span><span class="co">#&gt;    user  system elapsed </span></span>
<span><span class="co">#&gt;   8.060   5.677   7.166</span></span></code></pre></div>
<p>Having fitted the model, we can visualise the results. We first
decode the most probable state sequence and then plot the estimated
state-dependent densities as a function of the oil price, as well as the
decoded time series. For the former, we again create a fine grid of oil
price values and use <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> to build the associated
interpolating design matrix.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">xseq</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="va">energy</span><span class="op">$</span><span class="va">Oil</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">energy</span><span class="op">$</span><span class="va">Oil</span><span class="op">)</span>, length <span class="op">=</span> <span class="fl">200</span><span class="op">)</span> <span class="co"># sequence for prediction</span></span>
<span><span class="va">Z_p</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">modmat</span>, newdata <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>Oil <span class="op">=</span> <span class="va">xseq</span><span class="op">)</span><span class="op">)</span> <span class="co"># prediction design matrix</span></span>
<span></span>
<span><span class="va">energy</span><span class="op">$</span><span class="va">states</span> <span class="op">=</span> <span class="fu"><a href="../reference/viterbi.html">viterbi</a></span><span class="op">(</span>mod <span class="op">=</span> <span class="va">mod3</span><span class="op">)</span> <span class="co"># decoding most probable state sequence</span></span>
<span></span>
<span><span class="va">Mu_plot</span> <span class="op">=</span> <span class="va">Z_p</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">mod3</span><span class="op">$</span><span class="va">beta</span><span class="op">)</span></span>
<span><span class="va">Sigma_plot</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">Z_p</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">mod3</span><span class="op">$</span><span class="va">alpha</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://scales.r-lib.org" class="external-link">scales</a></span><span class="op">)</span> <span class="co"># to make colors semi-transparent</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># state-dependent distribution as a function of oil price</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">energy</span><span class="op">$</span><span class="va">Oil</span>, <span class="va">energy</span><span class="op">$</span><span class="va">Price</span>, pch <span class="op">=</span> <span class="fl">20</span>, bty <span class="op">=</span> <span class="st">"n"</span>, col <span class="op">=</span> <span class="fu"><a href="https://scales.r-lib.org/reference/alpha.html" class="external-link">alpha</a></span><span class="op">(</span><span class="va">color</span><span class="op">[</span><span class="va">energy</span><span class="op">$</span><span class="va">states</span><span class="op">]</span>, <span class="fl">0.1</span><span class="op">)</span>,</span>
<span>     xlab <span class="op">=</span> <span class="st">"oil price"</span>, ylab <span class="op">=</span> <span class="st">"energy price"</span><span class="op">)</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">xseq</span>, <span class="va">Mu_plot</span><span class="op">[</span>,<span class="va">j</span><span class="op">]</span>, col <span class="op">=</span> <span class="va">color</span><span class="op">[</span><span class="va">j</span><span class="op">]</span>, lwd <span class="op">=</span> <span class="fl">3</span><span class="op">)</span> <span class="co"># means</span></span>
<span><span class="va">qseq</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">qnorm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0.5</span>, <span class="fl">0.95</span>, length <span class="op">=</span> <span class="fl">4</span><span class="op">)</span><span class="op">)</span> <span class="co"># sequence of quantiles</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="va">qseq</span><span class="op">)</span><span class="op">{</span> <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">xseq</span>, <span class="va">Mu_plot</span><span class="op">[</span>,<span class="va">j</span><span class="op">]</span> <span class="op">+</span> <span class="va">i</span> <span class="op">*</span> <span class="va">Sigma_plot</span><span class="op">[</span>,<span class="va">j</span><span class="op">]</span>, col <span class="op">=</span> <span class="fu"><a href="https://scales.r-lib.org/reference/alpha.html" class="external-link">alpha</a></span><span class="op">(</span><span class="va">color</span><span class="op">[</span><span class="va">j</span><span class="op">]</span>, <span class="fl">0.7</span><span class="op">)</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">xseq</span>, <span class="va">Mu_plot</span><span class="op">[</span>,<span class="va">j</span><span class="op">]</span> <span class="op">-</span> <span class="va">i</span> <span class="op">*</span> <span class="va">Sigma_plot</span><span class="op">[</span>,<span class="va">j</span><span class="op">]</span>, col <span class="op">=</span> <span class="fu"><a href="https://scales.r-lib.org/reference/alpha.html" class="external-link">alpha</a></span><span class="op">(</span><span class="va">color</span><span class="op">[</span><span class="va">j</span><span class="op">]</span>, <span class="fl">0.7</span><span class="op">)</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">}</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html" class="external-link">legend</a></span><span class="op">(</span><span class="st">"topright"</span>, bty <span class="op">=</span> <span class="st">"n"</span>, legend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste</a></span><span class="op">(</span><span class="st">"state"</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">)</span>, col <span class="op">=</span> <span class="va">color</span>, lwd <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># decoded time series</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="cn">NA</span>, xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">energy</span><span class="op">)</span><span class="op">)</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">10</span><span class="op">)</span>, bty <span class="op">=</span> <span class="st">"n"</span>,</span>
<span>     xlab <span class="op">=</span> <span class="st">"time"</span>, ylab <span class="op">=</span> <span class="st">"energy price"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/segments.html" class="external-link">segments</a></span><span class="op">(</span>x0 <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">energy</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span>, x1 <span class="op">=</span> <span class="fl">2</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">energy</span><span class="op">)</span>,</span>
<span>         y0 <span class="op">=</span> <span class="va">energy</span><span class="op">$</span><span class="va">Price</span><span class="op">[</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">energy</span><span class="op">)</span><span class="op">]</span>, y1 <span class="op">=</span> <span class="va">energy</span><span class="op">$</span><span class="va">Price</span><span class="op">[</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span>, </span>
<span>         col <span class="op">=</span> <span class="va">color</span><span class="op">[</span><span class="va">energy</span><span class="op">$</span><span class="va">states</span><span class="op">[</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>, lwd <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="Penalised_splines_files/figure-html/energy_results-1.png" width="85%" style="display: block; margin: auto;"></p>
</div>
<div class="section level2">
<h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<!-- ### Full Laplace method -->
<!-- Lastly, we could have achieved a similar fit as above using the slightly more accurate full Laplace approximation method, which can be used to fit models via marginal maximum likelihood estimation by integrating out the random effects. This is natively supported by `RTMB` -- and actually one of its core selling points -- and the standard way we can now deal with all kinds of random effects.  -->
<!-- Indeed, the **qREML** algorithm above treats the spline coefficients as Gaussian random effects but exploits their relatively simple structure yiedling a more efficient fitting method. The full Laplace method is much more general, allowing for very flexible random effects, but here, estimation slower because it does not exploit the simple structure of splines treated as random effects. -->
<!-- We have to alter our likelihood function slightly, because for the Laplace method, we need to implement the joint likelihood of the data and the random effect, the latter having a multivariate normal distribution. Specifically, if $b$ is our random effect for a spline, $b \sim N(0, \lambda^{-1} S^-)$. The likelihood of the data given $b$ (just our regular likelihoot that treats $b$ as a parameter) is $f(x \mid b)$ and the density of $b$ is $f_{\lambda}(b)$. Hence the joint likelihood can be computed as -->
<!-- $$ -->
<!-- f(x, b) = f(x \mid b) f_{\lambda}(b) -->
<!-- $$ -->
<!-- and the joint negative log-likelihood becomes $- \log f(x \mid b) - \log f_{\lambda}(b)$ and this is what we implement below. -->
<!-- Most conveniently this is done by using the `dgmrf2()` function included in `LaMa` which provides the density function of the multivariate normal distribution reparametrized in terms of the (scaled) precision matrix, i.e. inverse covariance matrix, which in our case is $\lambda_i S$ for spline $i$. It allows evaluating at multiple points at once, each one possibly with its own penalty strength parameter `lambda`. It differs from `RTMB`'s `dgmrf()` by not expecting a *sparse* precision matrix and being more robust for rank-deficient penalty matrices, which are typical for penalized splines. -->
<!-- ```{r mllk4} -->
<!-- jnll = function(par) { -->
<!--   getAll(par, dat) # makes everything contained available without $ -->
<!--   Gamma = tpm_g(Z, cbind(beta0, betaspline)); ADREPORT(Gamma) -->
<!--   Delta = stationary_p(Gamma); ADREPORT(Delta) -->
<!--   delta = Delta[tod[1],] -->
<!--   # exponentiating because all parameters strictly positive -->
<!--   mu = exp(logmu); REPORT(mu) -->
<!--   sigma = exp(logsigma); REPORT(sigma) -->
<!--   kappa = exp(logkappa); REPORT(kappa) -->
<!--   # calculating all state-dependent densities -->
<!--   allprobs = matrix(1, nrow = length(step), ncol = N) -->
<!--   ind = which(!is.na(step) & !is.na(angle)) # only for non-NA obs. -->
<!--   for(j in 1:N){ -->
<!--     allprobs[ind,j] = dgamma2(step[ind],mu[j],sigma[j])*dvm(angle[ind],0,kappa[j]) -->
<!--   } -->
<!--   -forward_g(delta, Gamma[,,tod], allprobs) - -->
<!--     sum(dgmrf2(betaspline, 0, S, exp(loglambda), log = TRUE)) # just like any other density in R -->
<!-- } -->
<!-- ``` -->
<!-- We also have to include the log of our penalty strength as a parameter now. -->
<!-- ```{r todpar3} -->
<!-- par$loglambda = log(rep(100, 2)) -->
<!-- ``` -->
<!-- To create the objective function, we need to tell `RTMB` that `betaspline` is a random effect such that it is integrated out and as our objective function we have the marginal likelihood -->
<!-- $$ -->
<!-- f(x) = \int f(x, b) \,db, -->
<!-- $$ -->
<!-- actually its negative log of course. -->
<!-- ```{r refit, message = FALSE, eval = FALSE} -->
<!-- obj4 = MakeADFun(jnll, par, random = "betaspline", silent = TRUE) -->
<!-- system.time( -->
<!--   opt4 <- nlminb(obj4$par, obj4$fn, obj4$gr) -->
<!-- ) -->
<!-- ``` -->
<!-- This more general algorithm takes more than ten times model as long to fit the model. Hence, the above code is not evaluated. The results however are very similar. -->
<!-- ```{r results refit, fig.width = 8, fig.height = 5}
mod4 = obj4$report()
mod4$Gamma = tpm_g(Z, mod4$beta) # calculating 24 tpms

Gamma_plot = tpm_g(Z_pred, mod4$beta)
plot(tod_seq, Gamma_plot[1,2,], type = "l", lwd = 2, ylim = c(0,1),
     xlab = "time of day", ylab = "transition probability", bty = "n")
lines(tod_seq, Gamma_plot[2,1,], lwd = 2, lty = 3)
legend("topleft", lwd = 2, lty = c(1,3), bty = "n",
       legend = c(expression(gamma[12]^(t)), expression(gamma[21]^(t))))
``` -->
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-koslik2024efficient" class="csl-entry">
Koslik, Jan-Ole. 2024. <span>“Efficient Smoothness Selection for
Nonparametric <span>M</span>arkov-Switching Models via Quasi Restricted
Maximum Likelihood.”</span> <a href="https://arxiv.org/abs/2411.11498" class="external-link">https://arxiv.org/abs/2411.11498</a>.
</div>
<div id="ref-wood2017generalized" class="csl-entry">
Wood, Simon. 2017. <em>Generalized Additive Models: An Introduction with
r</em>. chapman; hall/CRC.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Jan-Ole Koslik.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
